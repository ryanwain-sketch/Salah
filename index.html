<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1a1a2e">
    <title>Mo Salah Goal Machine</title>

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://mosalahgame.com/">
    <meta property="og:title" content="Mo Salah Goal Machine - Pixel Soccer Game">
    <meta property="og:description" content="Play as Mo Salah and score goals! Dodge defenders, take free kicks, and become a legend. Can you beat my score?">
    <meta property="og:image" content="https://mosalahgame.com/og-image.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://mosalahgame.com/">
    <meta property="twitter:title" content="Mo Salah Goal Machine - Pixel Soccer Game">
    <meta property="twitter:description" content="Play as Mo Salah and score goals! Dodge defenders, take free kicks, and become a legend.">
    <meta property="twitter:image" content="https://mosalahgame.com/og-image.png">

    <!-- WhatsApp -->
    <meta property="og:site_name" content="Mo Salah Goal Machine">
    <!-- GameMonetize SDK for Ads -->
    <script src="https://api.gamemonetize.com/sdk.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Press Start 2P', monospace;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .game-container {
            text-align: center;
            padding: 5px;
            width: 100%;
            max-width: 100vw;
            max-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        h1 {
            color: #c8102e;
            font-size: clamp(12px, 4vw, 20px);
            margin-bottom: 5px;
            text-shadow: 2px 2px 0 #000;
            font-family: 'Press Start 2P', monospace;
        }

        .score-board {
            display: flex;
            justify-content: center;
            gap: clamp(8px, 2vw, 20px);
            margin-bottom: 5px;
            font-family: 'Press Start 2P', monospace;
            flex-wrap: wrap;
        }

        .score {
            color: #fff;
            font-size: clamp(8px, 2.5vw, 12px);
        }

        .goals { color: #4ade80; }
        .saves { color: #f87171; }
        .level { color: #60a5fa; }
        .total { color: #ffd700; }

        #canvasWrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            border: 3px solid #c8102e;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(200, 16, 46, 0.5);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            touch-action: none;
            max-width: 100%;
            height: auto;
        }

        .pause-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #ffd700;
            color: #ffd700;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            z-index: 50;
            font-family: 'Press Start 2P', monospace;
        }
        .pause-btn:active {
            background: rgba(255,215,0,0.3);
        }

        .sound-btn {
            position: absolute;
            top: 10px;
            right: 55px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ffd700;
            color: #ffd700;
            width: 36px;
            height: 28px;
            border-radius: 3px;
            cursor: pointer;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        .sound-btn:active {
            background: rgba(255,215,0,0.3);
        }
        /* Pixel speaker icon */
        .speaker-icon {
            display: flex;
            align-items: center;
        }
        .speaker-body {
            width: 6px;
            height: 8px;
            background: #ffd700;
        }
        .speaker-cone {
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 6px solid #ffd700;
        }
        .sound-waves {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-left: 3px;
        }
        .sound-wave {
            width: 3px;
            height: 3px;
            background: #ffd700;
            border-radius: 50%;
        }
        .sound-wave.w2 { margin-left: 2px; }
        .sound-wave.w3 { margin-left: 4px; }
        .sound-off .sound-waves { display: none; }
        .sound-off .speaker-body, .sound-off .speaker-cone { opacity: 0.4; }

        .instructions {
            color: #888;
            font-size: clamp(6px, 1.5vw, 8px);
            margin-top: 5px;
            font-family: 'Press Start 2P', monospace;
            line-height: 1.6;
        }

        .mobile-controls {
            display: none;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            padding: 0 10px;
            width: 100%;
            max-width: 800px;
            flex-shrink: 0;
        }

        @media (pointer: coarse) {
            .mobile-controls { display: flex; }
            .instructions { display: none; }
        }

        .joystick-area {
            width: clamp(70px, 15vw, 120px);
            height: clamp(70px, 15vw, 120px);
            background: rgba(255,255,255,0.15);
            border-radius: 50%;
            position: relative;
            border: 3px solid rgba(255,255,255,0.4);
            flex-shrink: 0;
        }

        .joystick-knob {
            width: 45%;
            height: 45%;
            background: rgba(200, 16, 46, 0.9);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid #fff;
        }

        .shoot-btn {
            width: clamp(60px, 14vw, 100px);
            height: clamp(60px, 14vw, 100px);
            background: linear-gradient(145deg, #c8102e, #a00d24);
            border-radius: 50%;
            border: 4px solid #ffd700;
            color: #fff;
            font-family: 'Press Start 2P', monospace;
            font-size: clamp(8px, 2vw, 12px);
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(200, 16, 46, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        /* Landscape mobile - FULL SCREEN canvas with overlay controls */
        @media (orientation: landscape) and (max-height: 500px) {
            .game-container {
                padding: 0;
                justify-content: center;
                align-items: center;
            }
            #canvasWrapper {
                width: 100vw;
                height: 100vh;
                max-width: none;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            #gameCanvas {
                max-height: 100vh !important;
                max-width: 100vw !important;
                object-fit: contain;
            }
            .mobile-controls {
                display: flex !important;
                position: fixed;
                bottom: 10px;
                left: 0;
                right: 0;
                justify-content: space-between;
                padding: 0 15px;
                background: transparent;
                pointer-events: none;
                z-index: 100;
            }
            .mobile-controls > * {
                pointer-events: auto;
            }
            .joystick-area {
                width: 100px;
                height: 100px;
            }
            .shoot-btn {
                width: 80px;
                height: 80px;
                font-size: 12px;
            }
            /* Hide UI elements - info is on canvas */
            h1, .score-board, .message, .instructions {
                display: none !important;
            }
        }

        /* Portrait mobile - stack vertically */
        @media (orientation: portrait) and (max-width: 600px) {
            .game-container {
                padding: 5px;
                justify-content: flex-start;
                padding-top: env(safe-area-inset-top, 10px);
            }
            h1 { font-size: 14px; margin-bottom: 3px; }
            .score-board { gap: 10px; margin-bottom: 3px; }
            .score { font-size: 9px; }
            .mobile-controls {
                margin-top: 8px;
                padding: 0 15px;
            }
        }

        /* Very small screens */
        @media (max-width: 380px) {
            h1 { font-size: 11px; }
            .score { font-size: 7px; }
            .joystick-area { width: 65px; height: 65px; }
            .shoot-btn { width: 55px; height: 55px; font-size: 7px; }
        }

        /* Large screens / desktop */
        @media (min-width: 1024px) {
            .game-container { padding: 20px; }
            h1 { font-size: 24px; }
            .score { font-size: 14px; }
        }

        .message {
            color: #ffd700;
            font-size: 11px;
            margin-top: 10px;
            font-family: 'Press Start 2P', monospace;
            min-height: 20px;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .overlay.hidden { display: none; }

        .menu {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 4px solid #c8102e;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .menu h2 {
            color: #c8102e;
            font-size: 18px;
            margin-bottom: 20px;
            font-family: 'Press Start 2P', monospace;
        }

        .menu input {
            padding: 12px;
            font-size: 14px;
            font-family: 'Press Start 2P', monospace;
            border: 3px solid #c8102e;
            border-radius: 8px;
            margin: 10px 0;
            width: 200px;
            text-align: center;
        }

        .menu button {
            padding: 15px 30px;
            font-size: 12px;
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(145deg, #c8102e, #a00d24);
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.1s;
        }

        .menu button:hover {
            transform: scale(1.05);
        }

        .leaderboard {
            margin-top: 20px;
            text-align: left;
        }

        .leaderboard h3 {
            color: #ffd700;
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
        }

        .leaderboard-entry {
            color: #fff;
            font-size: 10px;
            padding: 5px 0;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
        }

        .leaderboard-entry.gold { color: #ffd700; }
        .leaderboard-entry.silver { color: #c0c0c0; }
        .leaderboard-entry.bronze { color: #cd7f32; }

        /* Force GameMonetize ads to appear ABOVE game overlays */
        #GameMonetize-container,
        [id*="GameMonetize"],
        [class*="gamemonetize"],
        iframe[src*="gamemonetize"],
        div[style*="z-index: 99999"],
        div[style*="z-index:99999"] {
            z-index: 999999 !important;
        }

        /* When ad is playing, hide our overlays */
        body.ad-playing .overlay {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>MO SALAH GOAL MACHINE</h1>
        <div class="score-board">
            <span class="score level">LVL: <span id="level">1</span>/<span id="totalLevels">9</span></span>
            <span class="score goals">GOALS: <span id="goals">0</span>/<span id="target">2</span></span>
            <span class="score total">PTS: <span id="totalScore">0</span></span>
        </div>
        <div id="canvasWrapper">
            <canvas id="gameCanvas" width="800" height="500"></canvas>
            <button class="sound-btn sound-off" id="soundBtn" title="Music">
                <div class="speaker-icon">
                    <div class="speaker-body"></div>
                    <div class="speaker-cone"></div>
                    <div class="sound-waves">
                        <div class="sound-wave w1"></div>
                        <div class="sound-wave w2"></div>
                        <div class="sound-wave w3"></div>
                    </div>
                </div>
            </button>
            <button class="pause-btn" id="pauseBtn" title="Pause">‚ùö‚ùö</button>
        </div>
        <div class="message" id="message">Hold SHOOT to power up!</div>
        <div class="instructions">
            ARROWS/WASD - Move | HOLD SPACE - Power shot | Avoid defenders!
        </div>
        <div class="mobile-controls">
            <div class="joystick-area" id="joystick">
                <div class="joystick-knob" id="knob"></div>
            </div>
            <button class="shoot-btn" id="shootBtn">SHOOT</button>
        </div>
    </div>

    <!-- Start Menu Overlay -->
    <div class="overlay hidden" id="startOverlay">
        <div class="menu">
            <h2>MO SALAH<br>GOAL MACHINE</h2>
            <p style="color:#fff;font-size:10px;margin:15px 0;">Enter your name:</p>
            <input type="text" id="playerName" placeholder="YOUR NAME" maxlength="12">
            <br>
            <button id="startBtn">START GAME</button>
            <div class="leaderboard" id="leaderboard"></div>
        </div>
    </div>

    <!-- Ad Container -->
    <div class="overlay hidden" id="adOverlay">
        <div class="menu" style="padding:20px;min-width:280px;">
            <p style="color:#ffd700;font-size:14px;margin-bottom:10px;" id="adTitle">BONUS INCOMING!</p>
            <p style="color:#fff;font-size:24px;margin:20px 0;" id="adCountdown">5</p>
            <div id="gamemonetize-ad" style="min-height:80px;display:flex;align-items:center;justify-content:center;">
                <div style="color:#888;font-size:10px;" id="adStatus">Loading...</div>
            </div>
            <button id="closeAdBtn" style="margin-top:15px;padding:10px 20px;font-size:10px;background:#666;display:none;">SKIP</button>
        </div>
    </div>

    <!-- Level Complete Overlay -->
    <div class="overlay hidden" id="levelOverlay">
        <div class="menu">
            <h2 id="levelTitle">LEVEL COMPLETE!</h2>
            <p style="color:#4ade80;font-size:14px;margin:15px 0;" id="levelScore"></p>
            <p style="color:#fff;font-size:10px;margin:15px 0;" id="levelDesc"></p>
            <button id="nextLevelBtn">NEXT LEVEL</button>
            <button id="extraLifeBtn" style="background:linear-gradient(145deg,#22c55e,#16a34a);margin-top:5px;">üì∫ WATCH AD +1 LIFE</button>
        </div>
    </div>

    <!-- Game Over Overlay -->
    <div class="overlay hidden" id="gameOverOverlay">
        <div class="menu">
            <h2>GAME OVER</h2>
            <p style="color:#ffd700;font-size:16px;margin:15px 0;">Final Score: <span id="finalScore">0</span></p>
            <p style="color:#ff6b6b;font-size:12px;margin:5px 0;" id="bestStreakDisplay"></p>
            <p style="color:#fff;font-size:10px;margin:15px 0;" id="gameOverMsg"></p>
            <div style="margin:15px 0;">
                <p style="color:#fff;font-size:8px;margin-bottom:8px;">SHARE YOUR SCORE:</p>
                <button onclick="shareScore('x')" style="padding:8px 12px;font-size:10px;margin:3px;background:#000;">ùïè Post</button>
                <button onclick="shareScore('facebook')" style="padding:8px 12px;font-size:10px;margin:3px;background:#1877F2;">üìò Facebook</button>
                <button onclick="shareScore('whatsapp')" style="padding:8px 12px;font-size:10px;margin:3px;background:#25D366;">üí¨ WhatsApp</button>
                <button onclick="shareScore('copy')" style="padding:8px 12px;font-size:10px;margin:3px;background:#666;">üìã Copy</button>
                <button onclick="generateScoreCard()" style="padding:8px 12px;font-size:10px;margin:3px;background:#c8102e;">üì∏ Save Card</button>
            </div>
            <button id="continueAdBtn" style="background:linear-gradient(145deg,#22c55e,#16a34a);">üì∫ WATCH AD TO CONTINUE</button>
            <button id="playAgainBtn">PLAY AGAIN</button>
            <button id="mainMenuBtn">MAIN MENU</button>
            <div class="leaderboard" id="gameOverLeaderboard"></div>
        </div>
    </div>

    <!-- Intro Overlay -->
    <div class="overlay" id="introOverlay">
        <div style="text-align:center;">
            <canvas id="introCanvas" width="400" height="300" style="border-radius:8px;"></canvas>
            <button id="skipIntroBtn" style="margin-top:20px;padding:15px 40px;font-size:14px;font-family:'Press Start 2P',monospace;background:linear-gradient(145deg,#c8102e,#a00d24);color:#fff;border:4px solid #ffd700;border-radius:8px;cursor:pointer;animation:pulse 1s infinite;">SKIP INTRO</button>
        </div>
    </div>
    <style>
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px #ffd700; }
            50% { transform: scale(1.05); box-shadow: 0 0 20px #ffd700; }
        }
    </style>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ========== MO SALAH MUSIC (Web Audio API) ==========
        let audioCtx = null;
        let musicPlaying = false;
        let musicInterval = null;

        // "Mo Salah" melody (inspired by "Sit Down" by James)
        // Notes: Mo Sa-lah, Mo Sa-lah, Mo Sa-lah, running down the wing
        const moSalahMelody = [
            { note: 'E4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'D4', duration: 0.6 },
            { note: 'E4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'D4', duration: 0.6 },
            { note: 'E4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'D4', duration: 0.3 },
            { note: 'C4', duration: 0.3 },
            { note: 'D4', duration: 0.3 },
            { note: 'E4', duration: 0.6 },
            // "Sa-lah la la la la"
            { note: 'G4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'D4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'D4', duration: 0.3 },
            { note: 'C4', duration: 0.6 },
            // "The Egyptian King"
            { note: 'E4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'G4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'D4', duration: 0.6 },
            { note: 'rest', duration: 0.6 },
        ];

        const noteFrequencies = {
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
            'G4': 392.00, 'A4': 440.00, 'B4': 493.88, 'C5': 523.25,
            'rest': 0
        };

        function playNote(frequency, duration, startTime) {
            if (!audioCtx || frequency === 0) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'square'; // 8-bit style sound
            oscillator.frequency.value = frequency;

            // Envelope for nicer sound
            gainNode.gain.setValueAtTime(0.15, startTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration * 0.9);

            oscillator.start(startTime);
            oscillator.stop(startTime + duration);
        }

        function playMoSalahSong() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }

            let time = audioCtx.currentTime + 0.1;
            moSalahMelody.forEach(({ note, duration }) => {
                const freq = noteFrequencies[note];
                if (freq > 0) {
                    playNote(freq, duration, time);
                }
                time += duration;
            });

            // Return total duration for looping
            return moSalahMelody.reduce((sum, n) => sum + n.duration, 0) * 1000;
        }

        function toggleMusic() {
            const btn = document.getElementById('soundBtn');
            if (musicPlaying) {
                // Stop music
                musicPlaying = false;
                if (musicInterval) clearInterval(musicInterval);
                if (audioCtx) audioCtx.suspend();
                btn.classList.add('sound-off');
                btn.title = 'Music Off';
            } else {
                // Start music - MUST resume AudioContext on mobile
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                // Resume if suspended (required on mobile)
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                musicPlaying = true;
                btn.classList.remove('sound-off');
                btn.title = 'Music On';
                const songLength = playMoSalahSong();
                musicInterval = setInterval(() => {
                    if (musicPlaying && audioCtx.state === 'running') {
                        playMoSalahSong();
                    }
                }, songLength + 500); // Small gap between loops
            }
        }

        document.getElementById('soundBtn')?.addEventListener('click', toggleMusic);

        // ========== RESPONSIVE SCALING ==========
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 500;
        let canvasScale = 1;

        function resizeCanvas() {
            const wrapper = document.getElementById('canvasWrapper');
            const container = document.querySelector('.game-container');
            const isLandscape = window.innerWidth > window.innerHeight && window.innerHeight < 500;

            let maxWidth, maxHeight;

            if (isLandscape) {
                // Landscape: fill screen, leave small margin for controls
                maxWidth = window.innerWidth - 40;
                maxHeight = window.innerHeight - 20; // Minimal margin
            } else {
                // Portrait: leave room for UI elements
                maxWidth = Math.min(window.innerWidth - 20, 800);
                maxHeight = window.innerHeight - 200;
            }

            // Calculate scale to fit
            const scaleX = maxWidth / GAME_WIDTH;
            const scaleY = maxHeight / GAME_HEIGHT;
            canvasScale = Math.min(scaleX, scaleY, 1.5); // Allow scaling up to 1.5x in landscape

            // Apply size via CSS (keeps internal resolution)
            canvas.style.width = (GAME_WIDTH * canvasScale) + 'px';
            canvas.style.height = (GAME_HEIGHT * canvasScale) + 'px';

            // Also resize intro canvas
            const introCanvas = document.getElementById('introCanvas');
            if (introCanvas) {
                const introScale = Math.min(canvasScale * 1.2, 1);
                introCanvas.style.width = (400 * introScale) + 'px';
                introCanvas.style.height = (300 * introScale) + 'px';
            }
        }

        // Pause toggle
        let pauseDebounce = 0;

        function togglePause() {
            if (gameState === 'menu' || gameState === 'gameOver' || gameState === 'levelComplete') return;

            // Debounce to prevent accidental rapid toggling
            if (Date.now() - pauseDebounce < 300) return;
            pauseDebounce = Date.now();

            gamePaused = !gamePaused;
            const pauseBtn = document.getElementById('pauseBtn');
            if (gamePaused) {
                pauseBtn.textContent = '‚ñ∂';
                document.getElementById('message').textContent = 'PAUSED - Tap ‚ñ∂ to resume';
            } else {
                pauseBtn.textContent = '‚ùö‚ùö';
                document.getElementById('message').textContent = 'Hold SHOOT to power up!';
            }
        }

        document.getElementById('pauseBtn')?.addEventListener('click', togglePause);

        // Tap canvas to unpause (when paused)
        canvas.addEventListener('click', (e) => {
            if (gamePaused && gameState !== 'menu' && gameState !== 'gameOver') {
                togglePause();
            } else if (gameState === 'freeKick' && freeKickPhase === 'aim') {
                handleFreeKickZoneClick(e);
            }
        });
        canvas.addEventListener('touchend', (e) => {
            if (gamePaused && gameState !== 'menu' && gameState !== 'gameOver') {
                e.preventDefault();
                togglePause();
            } else if (gameState === 'freeKick' && freeKickPhase === 'aim') {
                e.preventDefault();
                handleFreeKickZoneClick(e.changedTouches[0]);
            }
        });

        function handleFreeKickZoneClick(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // Zone boundaries (matching drawFPVFreeKick zones)
            // Left zone: x 220-340, y 130-260
            // Center zone: x 340-460, y 130-260
            // Right zone: x 460-580, y 130-260
            if (y >= 130 && y <= 260) {
                if (x >= 220 && x < 340) {
                    fkSelectedZone = 'left';
                    document.getElementById('message').textContent = 'LEFT CORNER! Hold SHOOT for power!';
                } else if (x >= 340 && x < 460) {
                    fkSelectedZone = 'center';
                    document.getElementById('message').textContent = 'CENTER! Hold SHOOT for power!';
                } else if (x >= 460 && x <= 580) {
                    fkSelectedZone = 'right';
                    document.getElementById('message').textContent = 'RIGHT CORNER! Hold SHOOT for power!';
                }
            }
        }

        // Handle resize and orientation changes
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100); // Delay for orientation to settle
        });

        // Prevent unwanted touch behaviors
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('.overlay input')) return; // Allow scrolling in inputs
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('gesturestart', (e) => e.preventDefault());
        document.addEventListener('gesturechange', (e) => e.preventDefault());

        // Initial resize
        resizeCanvas();

        // ========== LEVEL CONFIGURATIONS ==========
        // Level configurations - easier start, gradual difficulty
        const levels = [
            { name: "Warm Up", target: 2, defenders: [], keeperSpeed: 0.012, desc: "Just you and Alisson. Easy start!" },
            { name: "Getting Started", target: 2, defenders: ['konate'], keeperSpeed: 0.015, defenderSpeed: 2.0, desc: "Konate joins but he's taking it easy!" },
            { name: "Van Dijk!", target: 2, defenders: ['konate', 'vandijk'], keeperSpeed: 0.018, defenderSpeed: 2.3, desc: "The big man Van Dijk arrives!" },
            { name: "Robertson Joins", target: 3, defenders: ['konate', 'vandijk', 'robertson'], keeperSpeed: 0.022, defenderSpeed: 2.5, desc: "Robertson adds to the defense!" },
            { name: "FREE KICK!", target: 1, defenders: [], keeperSpeed: 0.025, freeKick: true, wallSize: 3, desc: "Bonus Round! Bend it like Salah!" },
            { name: "Stepping Up", target: 3, defenders: ['konate', 'vandijk'], keeperSpeed: 0.028, defenderSpeed: 2.8, desc: "Defenders are getting serious!" },
            { name: "Full Squad", target: 3, defenders: ['konate', 'vandijk', 'robertson', 'bradley'], keeperSpeed: 0.032, defenderSpeed: 3.0, desc: "Bradley completes the back four!" },
            { name: "FINAL FREE KICK", target: 1, defenders: [], keeperSpeed: 0.035, freeKick: true, wallSize: 4, desc: "Bigger wall! Curve it in!" },
            { name: "SUDDEN DEATH", target: 999, defenders: ['konate', 'vandijk', 'robertson', 'bradley'], keeperSpeed: 0.04, defenderSpeed: 3.3, suddenDeath: true, desc: "ENDLESS MODE! Score until you drop!" }
        ];

        // Game state
        let currentLevel = 0;
        let levelGoals = 0;
        let totalScore = 0;
        let lives = 5;
        let playerName = '';
        let gameState = 'menu'; // menu, playing, shooting, celebrating, saved, tackled, freeKick, gameOver
        let gamePaused = false; // Pause game during ads/overlays

        // Combo/streak system
        let currentStreak = 0;
        let bestStreak = 0;
        let comboMultiplier = 1;
        let screenShake = 0;
        let lastGoalTime = 0;
        let deathCount = 0; // Track deaths for ad breaks

        // Free kick state - Simple 3-zone system
        let freeKickPhase = 'aim'; // aim, flying, done
        let fkSelectedZone = null; // 'left', 'center', 'right'
        let fkBallPos = { x: 400, y: 450, z: 0 }; // Ball 3D position for animation
        let fkBallVel = { x: 0, y: 0, z: 0 };
        let fkPower = 0;
        let wallPlayers = [];
        let fkKeeperPos = { x: 400, y: 180 }; // Keeper position in FPV
        let fkKeeperDiving = false;
        let fkKeeperDiveDir = 0;

        // Salah (player)
        const salah = {
            x: 200, y: 250, width: 32, height: 48, speed: 4,
            hasBall: true, kickFrame: 0, celebrating: false, celebrateFrame: 0
        };

        // Ball
        const ball = {
            x: 220, y: 270, radius: 8,
            velocityX: 0, velocityY: 0, curve: 0, active: false
        };

        // Alisson
        const alisson = {
            x: 700, y: 250, width: 36, height: 52,
            targetY: 250, speed: 3, diving: false, diveDirection: 0, diveFrame: 0
        };

        // Defenders
        const defenders = {
            konate: { x: 500, y: 250, speed: 2.5, tackleRange: 35, number: 5, skin: '#3d2314' },
            vandijk: { x: 450, y: 180, speed: 2.2, tackleRange: 38, number: 4, skin: '#d4a574' },
            robertson: { x: 480, y: 320, speed: 2.8, tackleRange: 32, number: 26, skin: '#f5d5c8' },
            bradley: { x: 420, y: 250, speed: 2.6, tackleRange: 30, number: 66, skin: '#f5d5c8' }
        };

        // Goal
        const goal = { x: 740, y: 150, width: 50, height: 200, postWidth: 8 };

        // Shot power
        let shotCharging = false;
        let shotPower = 0;
        let maxShotPower = 100;
        let chargeStartTime = 0;

        // Commentary
        const goalMessages = [
            'GOAL! The Egyptian King strikes!', 'SALAAAAH! What a finish!',
            'He makes it look so easy!', 'Running down the wing! SALAH!',
            'The Pharaoh has spoken!', 'Unstoppable from Mo Salah!',
            'Clinical finish! Pure class!', 'Alisson had no chance!',
            'WORLD CLASS!', 'The King of Egypt!'
        ];
        const saveMessages = [
            'SAVED by Alisson!', 'Great stop from Alisson!',
            'The Brazilian says NO!', 'Alisson stands tall!',
            'Denied by the keeper!', 'What a save! Alisson!'
        ];
        const missMessages = [
            'Over the bar! Too much power!', 'Blazed it over! So close!',
            'Into the stands!', 'Skied it!', 'Way too much on that one!'
        ];
        const tackleMessages = [
            'TACKLED!', 'Dispossessed!', 'Great defending!',
            'Ball won cleanly!', 'Reads it perfectly!'
        ];
        const freeKickMessages = [
            'WHAT A FREE KICK!', 'Bend it like Salah!',
            'Curled into the corner!', 'The wall had no chance!',
            'Absolutely magnificent!'
        ];

        function randomMessage(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // Global Leaderboard using Dreamlo
        const DREAMLO_PRIVATE = 'plQDO2UdfEytCaRU9D0M3QjzvR1a9VJkaQBeFOXWkNUg';
        const DREAMLO_PUBLIC = '697e8e208f40bb1184cada44';
        let globalLeaderboard = [];

        async function fetchLeaderboard() {
            try {
                const response = await fetch(`https://www.dreamlo.com/lb/${DREAMLO_PUBLIC}/json`);
                const data = await response.json();
                if (data.dreamlo && data.dreamlo.leaderboard && data.dreamlo.leaderboard.entry) {
                    let entries = data.dreamlo.leaderboard.entry;
                    // Handle single entry (not array)
                    if (!Array.isArray(entries)) entries = [entries];
                    globalLeaderboard = entries.map(e => ({
                        name: e.name,
                        score: parseInt(e.score),
                        streak: parseInt(e.seconds) || 0 // Streak stored in seconds field
                    }));
                } else {
                    globalLeaderboard = [];
                }
            } catch (err) {
                console.log('Leaderboard fetch error:', err);
                // Fallback to local storage
                const data = localStorage.getItem('salahLeaderboard');
                globalLeaderboard = data ? JSON.parse(data) : [];
            }
            return globalLeaderboard;
        }

        async function saveScore(name, score) {
            // Save to local storage as backup
            const local = localStorage.getItem('salahLeaderboard');
            const leaderboard = local ? JSON.parse(local) : [];
            leaderboard.push({ name, score, streak: bestStreak, date: Date.now() });
            leaderboard.sort((a, b) => b.score - a.score);
            localStorage.setItem('salahLeaderboard', JSON.stringify(leaderboard.slice(0, 50)));

            // Save to global Dreamlo leaderboard (with streak in text field)
            try {
                const safeName = encodeURIComponent(name.replace(/[^a-zA-Z0-9]/g, '').substring(0, 12) || 'PLAYER');
                // Dreamlo format: /add/name/score/seconds/text - we use seconds for streak
                await fetch(`https://www.dreamlo.com/lb/${DREAMLO_PRIVATE}/add/${safeName}/${score}/${bestStreak}`);
                console.log('Score saved globally with streak!');
            } catch (err) {
                console.log('Error saving to global leaderboard:', err);
            }
        }

        async function displayLeaderboard(elementId) {
            const container = document.getElementById(elementId);
            if (!container) return;

            container.innerHTML = '<h3>GLOBAL LEADERBOARD</h3><p style="color:#888;font-size:10px;">Loading...</p>';

            await fetchLeaderboard();

            let html = '<h3>GLOBAL LEADERBOARD</h3>';
            html += '<div style="display:flex;justify-content:space-between;font-size:8px;color:#888;padding:2px 5px;border-bottom:1px solid #333;"><span>PLAYER</span><span>SCORE</span><span>STREAK</span></div>';
            const top10 = globalLeaderboard.slice(0, 10);
            if (top10.length === 0) {
                html += '<p style="color:#888;font-size:10px;">No scores yet! Be the first!</p>';
            } else {
                top10.forEach((entry, i) => {
                    let cls = '';
                    if (i === 0) cls = 'gold';
                    else if (i === 1) cls = 'silver';
                    else if (i === 2) cls = 'bronze';
                    const streakDisplay = entry.streak > 0 ? `üî•${entry.streak}` : '-';
                    html += `<div class="leaderboard-entry ${cls}" style="display:flex;justify-content:space-between;">
                        <span style="flex:1;">${i + 1}. ${entry.name}</span>
                        <span style="width:50px;text-align:right;">${entry.score}</span>
                        <span style="width:40px;text-align:right;">${streakDisplay}</span>
                    </div>`;
                });
            }
            container.innerHTML = html;
        }

        // GameMonetize Ads Integration
        const GAME_ID = '4kci7og3klgj0ivy2wz3gdvd9dth5e7n';
        let adCallback = null;
        let adsWatched = 0;
        let sdkReady = false;

        // Initialize GameMonetize SDK
        function initGameMonetizeSDK() {
            if (typeof GameMonetize !== 'undefined') {
                GameMonetize.init({
                    gameId: GAME_ID,
                    onEvent: function(event) {
                        console.log('GameMonetize event:', event.name);
                        if (event.name === 'SDK_READY') {
                            sdkReady = true;
                            console.log('GameMonetize SDK ready!');
                        } else if (event.name === 'AD_SUCCESS' || event.name === 'AD_COMPLETED') {
                            adsWatched++;
                            document.getElementById('adOverlay').classList.add('hidden');
                            if (adCallback) adCallback(true);
                        } else if (event.name === 'AD_FAILED' || event.name === 'AD_REJECTED' || event.name === 'AD_DISMISS') {
                            console.log('Ad not available or dismissed');
                            document.getElementById('adOverlay').classList.add('hidden');
                            if (adCallback) adCallback(true); // Continue anyway
                        }
                    }
                });
            } else if (typeof sdk !== 'undefined' && sdk.init) {
                // Alternative SDK pattern
                sdk.init(GAME_ID);
                sdkReady = true;
            } else {
                console.log('GameMonetize SDK not found - ads will be simulated');
            }
        }

        // Try to init SDK when page loads
        window.addEventListener('load', initGameMonetizeSDK);

        let adCountdownInterval = null;

        // Track which overlay was showing before ad
        let overlayBeforeAd = null;

        function showAd(onComplete, isRewarded = false) {
            adCallback = onComplete;
            gamePaused = true; // PAUSE THE GAME

            // Remember which overlay was showing and hide ALL overlays for the ad
            overlayBeforeAd = null;
            ['levelOverlay', 'gameOverOverlay', 'startOverlay'].forEach(id => {
                const el = document.getElementById(id);
                if (el && !el.classList.contains('hidden')) {
                    overlayBeforeAd = id;
                    el.classList.add('hidden');
                }
            });

            // Add class to body so CSS can force GameMonetize to top
            document.body.classList.add('ad-playing');

            // Show our ad overlay (but it will be hidden by CSS while ad plays)
            document.getElementById('adOverlay').classList.remove('hidden');
            document.getElementById('closeAdBtn').style.display = 'none';
            document.getElementById('adTitle').textContent = isRewarded ? 'EARNING EXTRA LIFE!' : 'LOADING...';
            document.getElementById('adStatus').textContent = 'Please wait...';

            // Start countdown from 5
            let countdown = 5;
            document.getElementById('adCountdown').textContent = countdown;

            // Clear any existing interval
            if (adCountdownInterval) clearInterval(adCountdownInterval);

            adCountdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    document.getElementById('adCountdown').textContent = countdown;
                } else {
                    document.getElementById('adCountdown').textContent = isRewarded ? '+1 LIFE!' : 'GO!';
                    document.getElementById('adStatus').textContent = 'Ready!';
                }
            }, 1000);

            // Try to show real ad
            let adShown = false;
            if (typeof GameMonetize !== 'undefined' && GameMonetize.showAd) {
                try {
                    GameMonetize.showAd();
                    adShown = true;
                    console.log('Showing ad via GameMonetize.showAd()');
                } catch(e) {
                    console.log('GameMonetize.showAd error:', e);
                }
            }
            if (!adShown && typeof sdk !== 'undefined') {
                try {
                    if (sdk.showBanner) { sdk.showBanner(); adShown = true; }
                    else if (sdk.showAd) { sdk.showAd(); adShown = true; }
                } catch(e) { console.log('SDK ad error:', e); }
            }

            // Complete after countdown (5 seconds) regardless of ad
            setTimeout(() => {
                clearInterval(adCountdownInterval);
                finishAd(true);
            }, 5000);

            // Show skip button after 3 seconds
            setTimeout(() => {
                const skipBtn = document.getElementById('closeAdBtn');
                if (skipBtn && !document.getElementById('adOverlay').classList.contains('hidden')) {
                    skipBtn.style.display = 'block';
                }
            }, 3000);
        }

        function finishAd(success, keepPaused = false) {
            if (adCountdownInterval) {
                clearInterval(adCountdownInterval);
                adCountdownInterval = null;
            }

            // Remove ad-playing class
            document.body.classList.remove('ad-playing');

            document.getElementById('adOverlay').classList.add('hidden');
            document.getElementById('closeAdBtn').style.display = 'none';

            // Only unpause if not told to keep paused
            if (!keepPaused) {
                gamePaused = false;
            }
            adsWatched++;

            // Restore the overlay that was showing before ad (if any)
            if (overlayBeforeAd) {
                document.getElementById(overlayBeforeAd).classList.remove('hidden');
                overlayBeforeAd = null;
            }

            if (adCallback) {
                adCallback(success);
                adCallback = null;
            }
        }

        // Close ad button handler
        document.getElementById('closeAdBtn')?.addEventListener('click', () => {
            finishAd(true);
        });

        function showRewardedAd(onReward) {
            showAd((success) => {
                if (success && onReward) onReward();
            }, true); // true = isRewarded
        }

        // Share functionality
        const GAME_URL = 'https://mosalahgame.com';

        function shareScore(platform) {
            const text = `I scored ${totalScore} points in Mo Salah Goal Machine! Can you beat me? üèÜ‚öΩ`;
            const url = GAME_URL;

            switch(platform) {
                case 'x':
                    window.open(`https://x.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`, '_blank');
                    break;
                case 'whatsapp':
                    window.open(`https://wa.me/?text=${encodeURIComponent(text + ' ' + url)}`, '_blank');
                    break;
                case 'facebook':
                    window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}&quote=${encodeURIComponent(text)}`, '_blank');
                    break;
                case 'copy':
                    navigator.clipboard.writeText(text + ' ' + url).then(() => {
                        alert('Link copied! Share it with friends!');
                    });
                    break;
            }
        }

        // Generate shareable score card image
        function generateScoreCard() {
            const cardCanvas = document.createElement('canvas');
            cardCanvas.width = 600;
            cardCanvas.height = 400;
            const cardCtx = cardCanvas.getContext('2d');

            // Background gradient
            const grad = cardCtx.createLinearGradient(0, 0, 600, 400);
            grad.addColorStop(0, '#1a1a2e');
            grad.addColorStop(1, '#c8102e');
            cardCtx.fillStyle = grad;
            cardCtx.fillRect(0, 0, 600, 400);

            // Add pitch pattern
            cardCtx.fillStyle = 'rgba(45, 90, 39, 0.3)';
            for (let i = 0; i < 10; i++) {
                if (i % 2 === 0) {
                    cardCtx.fillRect(0, 280 + i * 12, 600, 12);
                }
            }

            // Title
            cardCtx.fillStyle = '#ffd700';
            cardCtx.font = 'bold 28px "Press Start 2P", monospace';
            cardCtx.textAlign = 'center';
            cardCtx.fillText('MO SALAH', 300, 60);
            cardCtx.fillText('GOAL MACHINE', 300, 100);

            // Score box
            cardCtx.fillStyle = 'rgba(0,0,0,0.6)';
            cardCtx.fillRect(100, 130, 400, 150);
            cardCtx.strokeStyle = '#ffd700';
            cardCtx.lineWidth = 4;
            cardCtx.strokeRect(100, 130, 400, 150);

            // Score
            cardCtx.fillStyle = '#fff';
            cardCtx.font = '16px "Press Start 2P", monospace';
            cardCtx.fillText('FINAL SCORE', 300, 170);

            cardCtx.fillStyle = '#ffd700';
            cardCtx.font = 'bold 48px "Press Start 2P", monospace';
            cardCtx.fillText(totalScore.toString(), 300, 230);

            // Stats
            cardCtx.fillStyle = '#fff';
            cardCtx.font = '10px "Press Start 2P", monospace';
            cardCtx.fillText(`BEST STREAK: ${bestStreak}x`, 300, 265);

            // Player name
            const playerName = document.getElementById('playerName')?.value || 'PLAYER';
            cardCtx.fillStyle = '#c8102e';
            cardCtx.fillRect(175, 300, 250, 35);
            cardCtx.fillStyle = '#fff';
            cardCtx.font = '12px "Press Start 2P", monospace';
            cardCtx.fillText(playerName.toUpperCase(), 300, 323);

            // Footer
            cardCtx.fillStyle = 'rgba(255,255,255,0.7)';
            cardCtx.font = '8px "Press Start 2P", monospace';
            cardCtx.fillText('mosalahgame.com - Play Now!', 300, 380);

            // Download the image
            const link = document.createElement('a');
            link.download = `mosalah-score-${totalScore}.png`;
            link.href = cardCanvas.toDataURL('image/png');
            link.click();
        }

        // Tips system
        const tips = [
            "TIP: Hold SHOOT longer for more power, but careful - too much goes over!",
            "TIP: Move unpredictably to dodge defenders!",
            "TIP: Shoot when defenders are far away!",
            "TIP: In free kicks, aim high for top corner screamers!",
            "TIP: Medium power (yellow bar) is often best!",
            "TIP: Watch the keeper's position before shooting!",
            "TIP: You can earn extra lives by watching ads!",
            "TIP: Share your score to challenge friends!"
        ];
        let currentTip = 0;
        let tipTimer = 0;

        function getNextTip() {
            const tip = tips[currentTip];
            currentTip = (currentTip + 1) % tips.length;
            return tip;
        }

        // Intro scene state
        let introActive = true;
        let introFrame = 0;
        let introBallX = 100;
        let introBallY = 250;
        let introPhase = 'run'; // run, kick, goal, celebrate

        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ') {
                handleShootPress();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'r' && gameState === 'playing') {
                resetPositions();
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            if (e.key === ' ') handleShootRelease();
        });

        // Mobile controls
        const joystick = document.getElementById('joystick');
        const knob = document.getElementById('knob');
        const shootBtn = document.getElementById('shootBtn');
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let touchMove = { x: 0, y: 0 };

        joystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
            const rect = joystick.getBoundingClientRect();
            joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        });

        document.addEventListener('touchmove', (e) => {
            if (!joystickActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            const maxDist = 30;
            let dx = touch.clientX - joystickCenter.x;
            let dy = touch.clientY - joystickCenter.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
            knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            touchMove = { x: dx / maxDist, y: dy / maxDist };
        }, { passive: false });

        document.addEventListener('touchend', () => {
            if (joystickActive) {
                joystickActive = false;
                knob.style.transform = 'translate(-50%, -50%)';
                touchMove = { x: 0, y: 0 };
            }
        });

        shootBtn.addEventListener('touchstart', (e) => { e.preventDefault(); handleShootPress(); });
        shootBtn.addEventListener('touchend', (e) => { e.preventDefault(); handleShootRelease(); });

        function handleShootPress() {
            if (gameState === 'playing' && salah.hasBall && !shotCharging) {
                startCharging();
            } else if (gameState === 'freeKick' && freeKickPhase === 'aim' && fkSelectedZone && !shotCharging) {
                // Only allow charging if a zone is selected
                startCharging();
            }
        }

        function handleShootRelease() {
            if (shotCharging) {
                if (gameState === 'playing' && salah.hasBall) {
                    shootBall(shotPower);
                } else if (gameState === 'freeKick' && freeKickPhase === 'aim' && fkSelectedZone) {
                    // Shoot to the selected zone
                    shootFPVFreeKick();
                }
                shotCharging = false;
                shotPower = 0;
            }
        }

        function startCharging() {
            shotCharging = true;
            chargeStartTime = Date.now();
            shotPower = 0;
        }

        function shootBall(power) {
            gameState = 'shooting';
            salah.hasBall = false;
            salah.kickFrame = 10;

            const powerPercent = power / maxShotPower;
            const basePower = 10 + powerPercent * 8;
            const aimVariance = (Math.random() - 0.5) * 60;

            let goingOver = false;
            if (powerPercent > 0.75 && Math.random() < (powerPercent - 0.5) * 0.8) {
                goingOver = true;
            }

            ball.targetY = goingOver ? goal.y - 50 - Math.random() * 100 : goal.y + goal.height / 2 + aimVariance;
            ball.active = true;
            ball.velocityX = basePower;
            ball.velocityY = (ball.targetY - ball.y) / ((goal.x - ball.x) / basePower);
            ball.curve = 0;

            const level = levels[currentLevel];
            const reactionDelay = 100 + Math.random() * 150 + (powerPercent * 50);
            setTimeout(() => {
                if (gameState === 'shooting') {
                    const predictedY = ball.y + ball.velocityY * ((alisson.x - ball.x) / ball.velocityX);
                    alisson.targetY = predictedY;
                    alisson.diving = true;
                    alisson.diveDirection = predictedY > alisson.y ? 1 : -1;
                }
            }, reactionDelay);
        }

        function shootFreeKick() {
            gameState = 'shooting';
            salah.kickFrame = 10;

            const power = shotPower || 60;
            const powerPercent = power / maxShotPower;
            const basePower = 8 + powerPercent * 6;

            // Bend affects curve - more bend = more curve but harder to control
            const bendPercent = (bendAmount - 50) / 50; // -1 to 1
            ball.curve = bendPercent * 0.3;

            // Target based on bend
            const targetY = goal.y + goal.height / 2 + bendPercent * 80;

            ball.active = true;
            ball.velocityX = basePower;
            ball.velocityY = (targetY - ball.y) / ((goal.x - ball.x) / basePower) - ball.curve * 5;

            // High bend = risk of missing
            if (Math.abs(bendPercent) > 0.7 && Math.random() < Math.abs(bendPercent) * 0.3) {
                ball.velocityY += (Math.random() - 0.5) * 4;
            }

            const level = levels[currentLevel];
            setTimeout(() => {
                if (gameState === 'shooting') {
                    const predictedY = ball.y + ball.velocityY * ((alisson.x - ball.x) / ball.velocityX);
                    alisson.targetY = predictedY + ball.curve * 50; // Keeper misjudges curve
                    alisson.diving = true;
                    alisson.diveDirection = predictedY > alisson.y ? 1 : -1;
                }
            }, 150);
        }

        function resetPositions() {
            const level = levels[currentLevel];

            if (level.freeKick) {
                salah.x = 400;
                salah.y = 350;
                ball.x = 420;
                ball.y = 365;
                gameState = 'freeKick';
                freeKickPhase = 'aim';
                setupWall(level.wallSize || 4);
                // Reset free kick state
                fkSelectedZone = null;
                fkBallPos = { x: 400, y: 480, z: 0 };
                fkBallVel = { x: 0, y: 0, z: 0 };
                fkKeeperPos = { x: 400, y: 180 };
                fkKeeperDiving = false;
                fkKeeperDiveDir = 0;
                fkPower = 0;
                document.getElementById('message').textContent = 'TAP a target zone, then HOLD SHOOT!';
            } else {
                salah.x = 200;
                salah.y = 250;
                ball.x = 220;
                ball.y = 270;
                gameState = 'playing';
                document.getElementById('message').textContent = 'Hold SHOOT to power up!';
            }

            salah.hasBall = true;
            salah.kickFrame = 0;
            salah.celebrating = false;
            salah.celebrateFrame = 0;
            ball.active = false;
            ball.velocityX = 0;
            ball.velocityY = 0;
            ball.curve = 0;
            alisson.x = 700;
            alisson.y = 250;
            alisson.diving = false;
            alisson.diveFrame = 0;
            shotCharging = false;
            shotPower = 0;

            // Reset defenders - positioned further back, especially for 3-defender level
            const defSpeed = level.defenderSpeed || 2.0;
            const isThreeDefenders = level.defenders?.length === 3;
            const defXOffset = isThreeDefenders ? 60 : 0; // Push back further on 3-defender level

            defenders.konate.x = 520 + defXOffset; defenders.konate.y = 250; defenders.konate.speed = defSpeed;
            defenders.vandijk.x = 480 + defXOffset; defenders.vandijk.y = 180; defenders.vandijk.speed = defSpeed * 0.9;
            defenders.robertson.x = 500 + defXOffset; defenders.robertson.y = 320; defenders.robertson.speed = defSpeed * 1.1;
            defenders.bradley.x = 450; defenders.bradley.y = 250; defenders.bradley.speed = defSpeed * 1.05;
        }

        function setupWall(size) {
            wallPlayers = [];
            const startY = goal.y + goal.height / 2 - (size * 25) / 2;
            for (let i = 0; i < size; i++) {
                wallPlayers.push({ x: 550, y: startY + i * 25, width: 20, height: 45 });
            }
        }

        function startLevel(levelIndex) {
            currentLevel = levelIndex;
            levelGoals = 0;
            const level = levels[currentLevel];
            document.getElementById('level').textContent = level.suddenDeath ? 'SD' : (currentLevel + 1);
            document.getElementById('totalLevels').textContent = levels.length;
            document.getElementById('target').textContent = level.suddenDeath ? '‚àû' : level.target;
            document.getElementById('goals').textContent = '0';
            resetPositions();
            document.getElementById('levelOverlay').classList.add('hidden');

            // Show sudden death announcement
            if (level.suddenDeath) {
                document.getElementById('message').textContent = 'SUDDEN DEATH! Score until you drop!';
            }
        }

        function completeLevel() {
            const level = levels[currentLevel];
            const bonus = level.freeKick ? 50 : level.target * 10;
            totalScore += bonus;
            document.getElementById('totalScore').textContent = totalScore;

            if (currentLevel < levels.length - 1) {
                const nextLevel = levels[currentLevel + 1];
                if (nextLevel.suddenDeath) {
                    document.getElementById('levelTitle').textContent = 'FINAL LEVEL!';
                    document.getElementById('levelScore').textContent = `+${bonus} points! Total: ${totalScore}`;
                    document.getElementById('levelDesc').textContent = 'SUDDEN DEATH: Endless mode! Score as many as you can before losing all lives. Your final score = LIMITLESS!';
                } else {
                    document.getElementById('levelTitle').textContent = 'LEVEL COMPLETE!';
                    document.getElementById('levelScore').textContent = `+${bonus} points!`;
                    document.getElementById('levelDesc').textContent = nextLevel.desc;
                }
                document.getElementById('levelOverlay').classList.remove('hidden');
                gameState = 'levelComplete';
            } else {
                // This shouldn't happen in Sudden Death but just in case
                endGame(true);
            }
        }

        async function endGame(completed) {
            // Don't trigger game over if ad is playing
            if (document.body.classList.contains('ad-playing')) {
                console.log('Prevented game over during ad');
                return;
            }

            gameState = 'gameOver';
            screenShake = 0; // Stop any screen shake
            document.getElementById('finalScore').textContent = totalScore;

            // Show best streak
            if (bestStreak >= 3) {
                document.getElementById('bestStreakDisplay').textContent = `üî• Best Streak: ${bestStreak} in a row!`;
            } else {
                document.getElementById('bestStreakDisplay').textContent = '';
            }

            const level = levels[currentLevel];
            let msg;
            if (level && level.suddenDeath) {
                msg = `SUDDEN DEATH: ${levelGoals} goals scored!`;
            } else if (completed) {
                msg = 'INCREDIBLE! You completed all levels!';
            } else {
                msg = `You reached Level ${currentLevel + 1}`;
            }
            document.getElementById('gameOverMsg').textContent = msg;
            document.getElementById('gameOverOverlay').classList.remove('hidden');

            // Save score and refresh leaderboard
            await saveScore(playerName, totalScore);
            await displayLeaderboard('gameOverLeaderboard');
        }

        function handleGoal() {
            levelGoals++;
            const level = levels[currentLevel];

            // Combo system - consecutive goals!
            currentStreak++;
            if (currentStreak > bestStreak) bestStreak = currentStreak;

            // Calculate combo multiplier (max 5x)
            comboMultiplier = Math.min(5, 1 + Math.floor(currentStreak / 2));

            // Base points with combo multiplier
            const basePoints = level.suddenDeath ? 15 : 10;
            const goalPoints = basePoints * comboMultiplier;
            totalScore += goalPoints;

            // Screen shake on goal!
            screenShake = 10;
            lastGoalTime = Date.now();

            document.getElementById('goals').textContent = levelGoals;
            document.getElementById('totalScore').textContent = totalScore;

            const isFreeKick = level.freeKick;
            const isSuddenDeath = level.suddenDeath;

            // Dynamic message based on streak
            let message = '';
            if (currentStreak >= 5) {
                message = `üî• ON FIRE! ${currentStreak} IN A ROW! +${goalPoints}pts (${comboMultiplier}x)`;
            } else if (currentStreak >= 3) {
                message = `‚ö° STREAK x${currentStreak}! +${goalPoints}pts (${comboMultiplier}x)`;
            } else if (comboMultiplier > 1) {
                message = `GOAL! +${goalPoints}pts (${comboMultiplier}x COMBO!)`;
            } else if (isSuddenDeath) {
                message = `GOAL #${levelGoals}! +${goalPoints} pts! Keep going!`;
            } else {
                message = isFreeKick ? randomMessage(freeKickMessages) : randomMessage(goalMessages);
            }
            document.getElementById('message').textContent = message;

            gameState = 'celebrating';
            salah.celebrating = true;
            salah.celebrateFrame = 0;

            setTimeout(() => {
                // In Sudden Death, never complete - just keep playing
                if (isSuddenDeath) {
                    resetPositions();
                } else if (levelGoals >= level.target) {
                    completeLevel();
                } else {
                    resetPositions();
                }
            }, 2000);
        }

        function handleMiss(isSave) {
            lives--;
            deathCount++;

            // Reset streak on miss
            if (currentStreak >= 3) {
                document.getElementById('message').textContent = `Streak ended at ${currentStreak}! ${isSave ? randomMessage(saveMessages) : randomMessage(missMessages)}`;
            } else {
                document.getElementById('message').textContent = isSave
                    ? randomMessage(saveMessages)
                    : randomMessage(missMessages);
            }
            currentStreak = 0;
            comboMultiplier = 1;
            gameState = 'saved';

            if (lives <= 0) {
                setTimeout(() => endGame(false), 1500);
            } else {
                // Show ad every 3rd death (not too annoying)
                if (deathCount % 3 === 0) {
                    setTimeout(() => {
                        showAd(() => {
                            // Reset positions FIRST, then pause
                            resetPositions();
                            setTimeout(() => {
                                gamePaused = true;
                                document.getElementById('pauseBtn').textContent = '‚ñ∂';
                                document.getElementById('message').textContent = 'Tap anywhere to play!';
                            }, 50);
                        });
                    }, 1500);
                } else {
                    setTimeout(resetPositions, 1500);
                }
            }
        }

        function handleTackle(defenderName) {
            lives--;
            deathCount++;
            currentStreak = 0;
            comboMultiplier = 1;

            const name = defenderName.charAt(0).toUpperCase() + defenderName.slice(1).replace('-', ' ');
            document.getElementById('message').textContent = `${name}: ${randomMessage(tackleMessages)}`;
            gameState = 'tackled';

            if (lives <= 0) {
                setTimeout(() => endGame(false), 1500);
            } else {
                // Show ad every 3rd death
                if (deathCount % 3 === 0) {
                    setTimeout(() => {
                        showAd(() => {
                            // Reset positions FIRST, then pause
                            resetPositions();
                            setTimeout(() => {
                                gamePaused = true;
                                document.getElementById('pauseBtn').textContent = '‚ñ∂';
                                document.getElementById('message').textContent = 'Tap anywhere to play!';
                            }, 50);
                        });
                    }, 1500);
                } else {
                    setTimeout(resetPositions, 1500);
                }
            }
        }

        // Drawing functions
        function drawField() {
            ctx.fillStyle = '#2d5a27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#347a2c';
            for (let i = 0; i < canvas.width; i += 60) ctx.fillRect(i, 0, 30, canvas.height);

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.strokeRect(600, 100, 200, 300);
            ctx.strokeRect(700, 175, 100, 150);

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(650, 250, 4, 0, Math.PI * 2);
            ctx.fill();

            // Free kick spot
            if (levels[currentLevel]?.freeKick) {
                ctx.beginPath();
                ctx.arc(420, 365, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Goal
            ctx.fillStyle = '#fff';
            ctx.fillRect(goal.x, goal.y, goal.postWidth, goal.height);
            ctx.fillRect(goal.x, goal.y, goal.width, goal.postWidth);
            ctx.fillRect(goal.x, goal.y + goal.height - goal.postWidth, goal.width, goal.postWidth);

            // Net
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            for (let i = goal.y; i < goal.y + goal.height; i += 15) {
                ctx.beginPath(); ctx.moveTo(goal.x + goal.postWidth, i); ctx.lineTo(goal.x + goal.width, i); ctx.stroke();
            }
            for (let i = goal.x + goal.postWidth; i < goal.x + goal.width; i += 15) {
                ctx.beginPath(); ctx.moveTo(i, goal.y); ctx.lineTo(i, goal.y + goal.height); ctx.stroke();
            }

            // Lives indicator
            ctx.fillStyle = '#c8102e';
            for (let i = 0; i < lives; i++) {
                ctx.beginPath();
                ctx.arc(30 + i * 25, 25, 8, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawSalah(x, y) {
            const skinColor = '#c68642';
            const hairColor = '#1a1a1a';
            const shirtColor = '#c8102e';

            // Curly hair
            ctx.fillStyle = hairColor;
            ctx.fillRect(x + 4, y - 4, 24, 12);
            ctx.fillRect(x, y, 8, 8);
            ctx.fillRect(x + 24, y, 8, 8);
            ctx.fillRect(x + 2, y + 6, 6, 8);
            ctx.fillRect(x + 24, y + 6, 6, 8);

            // Head
            ctx.fillStyle = skinColor;
            ctx.fillRect(x + 6, y + 4, 20, 18);

            // Eyes
            ctx.fillStyle = '#000';
            ctx.fillRect(x + 10, y + 10, 4, 4);
            ctx.fillRect(x + 18, y + 10, 4, 4);

            // Beard
            ctx.fillStyle = hairColor;
            ctx.fillRect(x + 6, y + 16, 20, 6);
            ctx.fillRect(x + 10, y + 14, 12, 4);

            // Body
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + 4, y + 22, 24, 18);

            // Number 11
            ctx.fillStyle = '#fff';
            ctx.fillRect(x + 10, y + 26, 3, 10);
            ctx.fillRect(x + 18, y + 26, 3, 10);

            // Arms
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x - 2, y + 22, 8, 14);
            ctx.fillRect(x + 26, y + 22, 8, 14);

            // Hands
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 2, y + 34, 6, 6);
            ctx.fillRect(x + 28, y + 34, 6, 6);

            // Shorts & legs
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + 6, y + 40, 20, 10);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x + 8, y + 50, 6, 10);
            ctx.fillRect(x + 18, y + 50, 6, 10);

            // Boots
            ctx.fillStyle = '#f97316';
            ctx.fillRect(x + 6, y + 58, 10, 6);
            ctx.fillRect(x + 16, y + 58, 10, 6);

            // Kick animation
            if (salah.kickFrame > 0) {
                ctx.fillStyle = skinColor;
                ctx.fillRect(x + 24, y + 48, 12, 6);
                ctx.fillStyle = '#f97316';
                ctx.fillRect(x + 32, y + 48, 10, 6);
            }

            // Celebration
            if (salah.celebrating) {
                const jump = Math.sin(salah.celebrateFrame * 0.3) * 10;
                const wave = Math.sin(salah.celebrateFrame * 0.5) * 8;
                ctx.fillStyle = shirtColor;
                ctx.fillRect(x - 6, y + 10 - jump + wave, 10, 16);
                ctx.fillRect(x + 28, y + 10 - jump - wave, 10, 16);
                ctx.fillStyle = skinColor;
                ctx.fillRect(x - 6, y + 4 - jump + wave, 8, 8);
                ctx.fillRect(x + 30, y + 4 - jump - wave, 8, 8);
            }
        }

        function drawAlisson(x, y, diving, diveDir) {
            const skinColor = '#d4a574';
            const hairColor = '#4a3728';
            const shirtColor = '#32CD32';
            const shortsColor = '#228B22';
            const glovesColor = '#FFD700';

            if (diving) {
                const offset = Math.min(alisson.diveFrame * 3, 40) * diveDir;
                y += offset;
                ctx.fillStyle = shirtColor;
                ctx.fillRect(x - 8, y + 16, 40, 16);
                ctx.fillRect(x - 16, y + 8, 16, 12);
                ctx.fillRect(x + 32, y + 8, 16, 12);
                ctx.fillStyle = glovesColor;
                ctx.fillRect(x - 24, y + 8, 12, 16);
                ctx.fillRect(x + 44, y + 8, 12, 16);
                ctx.fillStyle = skinColor;
                ctx.fillRect(x + 8, y, 20, 20);
                ctx.fillStyle = hairColor;
                ctx.fillRect(x + 8, y, 20, 8);
                ctx.fillStyle = shortsColor;
                ctx.fillRect(x, y + 32, 32, 8);
            } else {
                ctx.fillStyle = skinColor;
                ctx.fillRect(x + 8, y, 20, 20);
                ctx.fillStyle = hairColor;
                ctx.fillRect(x + 8, y, 20, 8);
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 12, y + 10, 4, 4);
                ctx.fillRect(x + 20, y + 10, 4, 4);
                ctx.fillStyle = shirtColor;
                ctx.fillRect(x + 4, y + 20, 28, 20);
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 16, y + 24, 4, 12);
                ctx.fillStyle = shirtColor;
                ctx.fillRect(x - 4, y + 20, 8, 16);
                ctx.fillRect(x + 32, y + 20, 8, 16);
                ctx.fillStyle = glovesColor;
                ctx.fillRect(x - 4, y + 32, 10, 10);
                ctx.fillRect(x + 30, y + 32, 10, 10);
                ctx.fillStyle = shortsColor;
                ctx.fillRect(x + 6, y + 40, 24, 10);
                ctx.fillStyle = skinColor;
                ctx.fillRect(x + 8, y + 50, 8, 12);
                ctx.fillRect(x + 20, y + 50, 8, 12);
                ctx.fillStyle = '#111';
                ctx.fillRect(x + 6, y + 60, 12, 6);
                ctx.fillRect(x + 18, y + 60, 12, 6);
            }
        }

        function drawDefender(x, y, number, skinColor) {
            const hairColor = '#1a1a1a';
            const shirtColor = '#c8102e';

            ctx.fillStyle = hairColor;
            ctx.fillRect(x + 6, y - 2, 20, 6);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x + 6, y + 2, 20, 20);
            ctx.fillStyle = '#fff';
            ctx.fillRect(x + 10, y + 10, 5, 4);
            ctx.fillRect(x + 17, y + 10, 5, 4);
            ctx.fillStyle = '#000';
            ctx.fillRect(x + 12, y + 11, 2, 2);
            ctx.fillRect(x + 19, y + 11, 2, 2);
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + 2, y + 22, 28, 22);

            // Number
            ctx.fillStyle = '#fff';
            ctx.font = '10px monospace';
            ctx.fillText(number.toString(), x + 10, y + 38);

            ctx.fillStyle = shirtColor;
            ctx.fillRect(x - 4, y + 22, 8, 16);
            ctx.fillRect(x + 28, y + 22, 8, 16);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 4, y + 36, 6, 6);
            ctx.fillRect(x + 30, y + 36, 6, 6);
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + 4, y + 44, 24, 12);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x + 6, y + 56, 8, 14);
            ctx.fillRect(x + 18, y + 56, 8, 14);
            ctx.fillStyle = '#111';
            ctx.fillRect(x + 4, y + 68, 12, 6);
            ctx.fillRect(x + 16, y + 68, 12, 6);
        }

        function drawWall() {
            wallPlayers.forEach(p => {
                ctx.fillStyle = '#c8102e';
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(p.x + 4, p.y, 12, 12);
            });
        }

        function drawBall() {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(ball.x + 2, ball.y + ball.radius + 4, ball.radius, ball.radius / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(ball.x - 2, ball.y - 2, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPowerMeter() {
            if (shotCharging) {
                const meterWidth = 100;
                const meterHeight = 12;
                const x = salah.x - 20;
                const y = salah.y - 30;
                const fillWidth = (shotPower / maxShotPower) * meterWidth;

                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(x - 2, y - 2, meterWidth + 4, meterHeight + 4);

                const powerPercent = shotPower / maxShotPower;
                ctx.fillStyle = powerPercent < 0.5 ? '#4ade80' : powerPercent < 0.75 ? '#fbbf24' : '#ef4444';
                ctx.fillRect(x, y, fillWidth, meterHeight);

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, meterWidth, meterHeight);

                ctx.fillStyle = '#fff';
                ctx.font = '8px monospace';
                ctx.fillText('POWER', x + 30, y - 5);
            }
        }

        function drawBendMeter() {
            if (gameState === 'bendSelect') {
                const meterWidth = 200;
                const meterHeight = 20;
                const x = canvas.width / 2 - meterWidth / 2;
                const y = 50;

                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(x - 5, y - 25, meterWidth + 10, meterHeight + 35);

                // Gradient for bend
                const gradient = ctx.createLinearGradient(x, 0, x + meterWidth, 0);
                gradient.addColorStop(0, '#3b82f6');
                gradient.addColorStop(0.5, '#4ade80');
                gradient.addColorStop(1, '#f59e0b');
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, meterWidth, meterHeight);

                // Indicator
                const indicatorX = x + (bendAmount / 100) * meterWidth;
                ctx.fillStyle = '#fff';
                ctx.fillRect(indicatorX - 3, y - 5, 6, meterHeight + 10);

                ctx.fillStyle = '#fff';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('LEFT          STRAIGHT          RIGHT', x + meterWidth / 2, y - 10);
                ctx.fillText('TAP SHOOT TO CONFIRM', x + meterWidth / 2, y + meterHeight + 15);
                ctx.textAlign = 'left';
            }
        }

        // ========== FPV FREE KICK SYSTEM ==========
        function drawFPVFreeKick() {
            // Sky gradient
            const skyGrad = ctx.createLinearGradient(0, 0, 0, 250);
            skyGrad.addColorStop(0, '#1a1a3e');
            skyGrad.addColorStop(1, '#2d4a6e');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, canvas.width, 250);

            // Stadium lights glow
            ctx.fillStyle = 'rgba(255,255,200,0.1)';
            ctx.beginPath();
            ctx.arc(200, 50, 80, 0, Math.PI * 2);
            ctx.arc(600, 50, 80, 0, Math.PI * 2);
            ctx.fill();

            // Pitch - perspective
            const pitchGrad = ctx.createLinearGradient(0, 250, 0, 500);
            pitchGrad.addColorStop(0, '#2d5a27');
            pitchGrad.addColorStop(1, '#1d4a17');
            ctx.fillStyle = pitchGrad;
            ctx.fillRect(0, 250, canvas.width, 250);

            // Pitch stripes (perspective)
            ctx.fillStyle = '#347a2c';
            for (let i = 0; i < 8; i++) {
                const y1 = 250 + i * 30;
                const y2 = 250 + (i + 1) * 30;
                if (i % 2 === 0) {
                    ctx.beginPath();
                    ctx.moveTo(0, y1);
                    ctx.lineTo(canvas.width, y1);
                    ctx.lineTo(canvas.width, y2);
                    ctx.lineTo(0, y2);
                    ctx.fill();
                }
            }

            // Goal frame (perspective - larger at bottom)
            const goalTop = 120;
            const goalBottom = 280;
            const goalLeft = 200;
            const goalRight = 600;
            const goalTopLeft = 280;
            const goalTopRight = 520;

            // Goal net
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 10; i++) {
                const x1 = goalTopLeft + (goalLeft - goalTopLeft) * (i / 10);
                const x2 = goalTopRight + (goalRight - goalTopRight) * (i / 10);
                const y = goalTop + (goalBottom - goalTop) * (i / 10);
                ctx.beginPath();
                ctx.moveTo(x1, y);
                ctx.lineTo(x2, y);
                ctx.stroke();
            }
            for (let i = 0; i <= 8; i++) {
                const topX = goalTopLeft + (goalTopRight - goalTopLeft) * (i / 8);
                const botX = goalLeft + (goalRight - goalLeft) * (i / 8);
                ctx.beginPath();
                ctx.moveTo(topX, goalTop);
                ctx.lineTo(botX, goalBottom);
                ctx.stroke();
            }

            // Goal posts
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(goalTopLeft, goalTop);
            ctx.lineTo(goalLeft, goalBottom);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(goalTopRight, goalTop);
            ctx.lineTo(goalRight, goalBottom);
            ctx.stroke();
            // Crossbar
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(goalTopLeft, goalTop);
            ctx.lineTo(goalTopRight, goalTop);
            ctx.stroke();

            // Keeper (Alisson) - FPV view
            const keeperX = fkKeeperPos.x;
            const keeperY = fkKeeperPos.y;
            if (fkKeeperDiving) {
                // Diving keeper
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(keeperX - 25 + fkKeeperDiveDir * 30, keeperY, 50, 20);
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(keeperX - 10 + fkKeeperDiveDir * 40, keeperY - 5, 15, 15);
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(keeperX - 30 + fkKeeperDiveDir * 50, keeperY, 12, 12);
            } else {
                // Standing keeper
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(keeperX - 15, keeperY, 30, 50);
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(keeperX - 10, keeperY - 15, 20, 20);
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(keeperX - 25, keeperY + 10, 12, 15);
                ctx.fillRect(keeperX + 13, keeperY + 10, 12, 15);
            }

            // Wall of defenders (facing camera!)
            const wallY = 320;
            const level = levels[currentLevel];
            const wallSize = level.wallSize || 3;
            const wallSpacing = 45;
            const wallStartX = 400 - ((wallSize - 1) * wallSpacing) / 2;

            for (let i = 0; i < wallSize; i++) {
                const wx = wallStartX + i * wallSpacing;
                // Body (facing us)
                ctx.fillStyle = '#c8102e';
                ctx.fillRect(wx - 18, wallY, 36, 45);
                // Head
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(wx - 12, wallY - 18, 24, 22);
                // Hair
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(wx - 12, wallY - 18, 24, 8);
                // Eyes (looking at ball nervously)
                ctx.fillStyle = '#fff';
                ctx.fillRect(wx - 8, wallY - 8, 7, 5);
                ctx.fillRect(wx + 1, wallY - 8, 7, 5);
                ctx.fillStyle = '#000';
                ctx.fillRect(wx - 5, wallY - 7, 3, 3);
                ctx.fillRect(wx + 4, wallY - 7, 3, 3);
                // Hands covering... area
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(wx - 10, wallY + 30, 20, 12);
                // Legs
                ctx.fillStyle = '#c8102e';
                ctx.fillRect(wx - 14, wallY + 45, 12, 20);
                ctx.fillRect(wx + 2, wallY + 45, 12, 20);
            }

            // Player lying BEHIND the wall
            ctx.fillStyle = '#c8102e';
            ctx.fillRect(340, wallY + 65, 50, 12);
            ctx.fillStyle = '#d4a574';
            ctx.fillRect(330, wallY + 63, 12, 12);

            // 3 TAPPABLE TARGET ZONES
            if (freeKickPhase === 'aim') {
                // Zone definitions
                const zones = [
                    { id: 'left', x: 220, y: 130, w: 120, h: 130, label: 'LEFT', chance: '70%' },
                    { id: 'center', x: 340, y: 130, w: 120, h: 130, label: 'CENTER', chance: '40%' },
                    { id: 'right', x: 460, y: 130, w: 120, h: 130, label: 'RIGHT', chance: '70%' }
                ];

                zones.forEach(zone => {
                    const isSelected = fkSelectedZone === zone.id;
                    const isCorner = zone.id !== 'center';

                    // Zone background
                    if (isSelected) {
                        ctx.fillStyle = 'rgba(74, 222, 128, 0.5)'; // Green when selected
                    } else if (isCorner) {
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.15)'; // Light green for corners
                    } else {
                        ctx.fillStyle = 'rgba(255, 165, 0, 0.15)'; // Orange for center
                    }
                    ctx.fillRect(zone.x, zone.y, zone.w, zone.h);

                    // Zone border
                    ctx.strokeStyle = isSelected ? '#4ade80' : '#fff';
                    ctx.lineWidth = isSelected ? 4 : 2;
                    ctx.strokeRect(zone.x, zone.y, zone.w, zone.h);

                    // Zone label
                    ctx.fillStyle = isSelected ? '#4ade80' : '#fff';
                    ctx.font = isSelected ? 'bold 16px monospace' : 'bold 14px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(zone.label, zone.x + zone.w / 2, zone.y + zone.h / 2 - 10);

                    // Score chance
                    ctx.font = '11px monospace';
                    ctx.fillStyle = isCorner ? '#4ade80' : '#fbbf24';
                    ctx.fillText(zone.chance + ' score', zone.x + zone.w / 2, zone.y + zone.h / 2 + 10);
                });

                // Instructions
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'center';
                if (!fkSelectedZone) {
                    ctx.fillText('TAP A TARGET ZONE!', 400, 75);
                    ctx.font = '12px monospace';
                    ctx.fillStyle = '#fff';
                    ctx.fillText('Corners are easier to score', 400, 95);
                } else {
                    ctx.fillStyle = '#4ade80';
                    ctx.fillText(fkSelectedZone.toUpperCase() + ' SELECTED!', 400, 75);
                    ctx.font = '12px monospace';
                    ctx.fillStyle = '#fff';
                    ctx.fillText('Hold SHOOT button for power!', 400, 95);
                }
                ctx.fillText('TAP zone to aim | HOLD SHOOT for power', 400, 470);
                ctx.textAlign = 'left';
            }

            // Power meter (when charging with zone selected)
            if (shotCharging && freeKickPhase === 'aim' && fkSelectedZone) {
                const pw = 200;
                const ph = 25;
                const px = 300;
                const py = 420;
                const fill = (shotPower / maxShotPower) * pw;

                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(px - 10, py - 30, pw + 20, ph + 50);

                const powerPct = shotPower / maxShotPower;
                ctx.fillStyle = powerPct < 0.5 ? '#4ade80' : powerPct < 0.8 ? '#fbbf24' : '#ef4444';
                ctx.fillRect(px, py, fill, ph);

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(px, py, pw, ph);

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('POWER', 400, py - 10);
                ctx.font = '11px monospace';
                if (powerPct < 0.5) ctx.fillText('Good power - release!', 400, py + 45);
                else if (powerPct < 0.8) ctx.fillText('Strong shot!', 400, py + 45);
                else ctx.fillText('MAX POWER!', 400, py + 45);
                ctx.textAlign = 'left';
            }

            // Ball in flight
            if (freeKickPhase === 'flying') {
                const ballSize = 15 - fkBallPos.z * 0.03;
                const ballScreenX = fkBallPos.x;
                const ballScreenY = fkBallPos.y - fkBallPos.z * 0.5;

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(ballScreenX, ballScreenY, Math.max(ballSize, 3), 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(ballScreenX - 2, ballScreenY - 2, ballSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Ball at feet (before shot)
            if (freeKickPhase === 'aim') {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(400, 480, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(396, 476, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function updateFPVFreeKick() {
            // No joystick aiming needed - user taps zones directly

            // Ball in flight physics
            if (freeKickPhase === 'flying') {
                fkBallPos.x += fkBallVel.x;
                fkBallPos.y += fkBallVel.y;
                fkBallPos.z += fkBallVel.z;

                // Gravity effect on arc
                if (fkBallVel.z > 0) {
                    fkBallVel.z -= 0.10;
                }

                // Keeper reaction - decides which way to dive
                if (!fkKeeperDiving && fkBallPos.z > 40) {
                    fkKeeperDiving = true;
                    // Keeper dives based on zone - often wrong for corners!
                    if (fkSelectedZone === 'left') {
                        // 80% chance keeper dives wrong way for corners
                        fkKeeperDiveDir = Math.random() < 0.80 ? 1 : -1;
                    } else if (fkSelectedZone === 'right') {
                        fkKeeperDiveDir = Math.random() < 0.80 ? -1 : 1;
                    } else {
                        // Center: keeper stays put 60% of time
                        if (Math.random() < 0.6) {
                            fkKeeperDiveDir = 0;
                        } else {
                            fkKeeperDiveDir = Math.random() < 0.5 ? -1 : 1;
                        }
                    }
                }

                // Move keeper - but CLAMP to stay on screen!
                if (fkKeeperDiving && fkKeeperDiveDir !== 0) {
                    fkKeeperPos.x += fkKeeperDiveDir * 5;
                    // Keep keeper within goal bounds (posts are ~280 to ~520)
                    fkKeeperPos.x = Math.max(290, Math.min(510, fkKeeperPos.x));
                }

                // Check if ball reached goal (only trigger once!)
                if (fkBallPos.z > 150) {
                    freeKickPhase = 'done';

                    // Simpler goal detection - based on where ball is heading
                    const ballHeadingX = fkBallPos.x;

                    // Goal bounds (wide and forgiving)
                    const leftPost = 250;
                    const rightPost = 550;

                    // Is keeper in the way?
                    const keeperDist = Math.abs(ballHeadingX - fkKeeperPos.x);
                    const keeperSaveRange = 50; // Keeper can save within 50px

                    // Check if ball is heading into goal area
                    const headingIntoGoal = ballHeadingX > leftPost && ballHeadingX < rightPost;

                    // Simple outcome logic
                    if (!headingIntoGoal) {
                        // Missed wide
                        document.getElementById('message').textContent = ballHeadingX < leftPost ? 'WIDE LEFT!' : 'WIDE RIGHT!';
                        handleMiss(false);
                    } else if (keeperDist < keeperSaveRange) {
                        // Keeper saves it
                        document.getElementById('message').textContent = randomMessage(saveMessages);
                        handleMiss(true);
                    } else {
                        // GOAL! Keeper was wrong way
                        // Small chance of post/bar drama
                        const rand = Math.random();
                        if (rand < 0.05) {
                            document.getElementById('message').textContent = 'OFF THE POST AND IN!!!';
                        } else if (rand < 0.08) {
                            document.getElementById('message').textContent = 'OFF THE BAR AND IN!!!';
                        } else {
                            document.getElementById('message').textContent = randomMessage(freeKickMessages);
                        }
                        handleGoal();
                    }
                }
            }
        }

        function shootFPVFreeKick() {
            freeKickPhase = 'flying';
            fkPower = shotPower;
            const powerPct = fkPower / maxShotPower;

            // Simple target based on zone - ball reliably goes where you aim
            let targetX;
            if (fkSelectedZone === 'left') {
                targetX = 300 + Math.random() * 30; // Left side of goal
            } else if (fkSelectedZone === 'right') {
                targetX = 470 + Math.random() * 30; // Right side of goal
            } else {
                targetX = 385 + Math.random() * 30; // Center
            }

            // Ball velocity - simple and reliable
            const dx = targetX - 400;
            fkBallVel.x = dx * 0.06;
            fkBallVel.y = -8; // Always moves towards goal
            fkBallVel.z = 4 + powerPct * 3; // Gentle arc

            // Reset ball position
            fkBallPos = { x: 400, y: 480, z: 0 };

            shotCharging = false;
            shotPower = 0;

            // Safety timeout - if ball doesn't reach goal in 5 seconds, force completion
            setTimeout(() => {
                if (freeKickPhase === 'flying') {
                    console.log('Free kick safety timeout triggered');
                    freeKickPhase = 'done';
                    document.getElementById('message').textContent = randomMessage(missMessages);
                    handleMiss(false);
                }
            }, 5000);
        }

        function drawCelebration() {
            if (gameState === 'celebrating') {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                for (let i = 0; i < 20; i++) {
                    ctx.fillStyle = ['#c8102e', '#ffd700', '#fff'][Math.floor(Math.random() * 3)];
                    ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 8, 8);
                }
            }
        }

        function updateGame() {
            if (gameState === 'menu' || gameState === 'levelComplete' || gameState === 'gameOver' || gamePaused) return;

            // Update shot power
            if (shotCharging) {
                shotPower = Math.min(maxShotPower, (Date.now() - chargeStartTime) / 10);
            }

            const level = levels[currentLevel];

            // Move Salah (not in free kick)
            if (gameState === 'playing' && !level.freeKick) {
                if ((keys['arrowleft'] || keys['a']) && salah.x > 50) salah.x -= salah.speed;
                if ((keys['arrowright'] || keys['d']) && salah.x < 600) salah.x += salah.speed;
                if ((keys['arrowup'] || keys['w']) && salah.y > 50) salah.y -= salah.speed;
                if ((keys['arrowdown'] || keys['s']) && salah.y < 420) salah.y += salah.speed;

                if (touchMove.x !== 0 || touchMove.y !== 0) {
                    const newX = salah.x + touchMove.x * salah.speed;
                    const newY = salah.y + touchMove.y * salah.speed;
                    if (newX > 50 && newX < 600) salah.x = newX;
                    if (newY > 50 && newY < 420) salah.y = newY;
                }

                if (salah.hasBall) {
                    ball.x = salah.x + 20;
                    ball.y = salah.y + 45;
                }

                // Defenders chase
                level.defenders.forEach(defName => {
                    const def = defenders[defName];
                    if (!def) return;
                    const dx = salah.x - def.x;
                    const dy = salah.y - def.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 5) {
                        def.x += (dx / dist) * def.speed;
                        def.y += (dy / dist) * def.speed;
                    }
                    if (salah.hasBall && dist < def.tackleRange) {
                        handleTackle(defName);
                    }
                });
            }

            // Update ball
            if (ball.active) {
                ball.x += ball.velocityX;
                ball.y += ball.velocityY;
                ball.velocityY += ball.curve; // Apply curve

                // Check wall collision (free kick)
                if (level.freeKick) {
                    for (const p of wallPlayers) {
                        if (ball.x > p.x && ball.x < p.x + p.width + 10 &&
                            ball.y > p.y && ball.y < p.y + p.height) {
                            ball.velocityX *= -0.3;
                            ball.velocityY = (Math.random() - 0.5) * 8;
                            document.getElementById('message').textContent = 'Blocked by the wall!';
                            gameState = 'saved';
                            setTimeout(() => handleMiss(false), 1000);
                            break;
                        }
                    }
                }

                // Goal check
                if (ball.x >= goal.x && ball.y > goal.y + goal.postWidth && ball.y < goal.y + goal.height - goal.postWidth) {
                    if (gameState === 'shooting') handleGoal();
                }

                // Save check
                if (ball.x > alisson.x - 20 && ball.x < alisson.x + alisson.width + 20 &&
                    ball.y > alisson.y - 10 && ball.y < alisson.y + alisson.height + 20) {
                    if (gameState === 'shooting') {
                        ball.velocityX = -ball.velocityX * 0.5;
                        ball.velocityY = (Math.random() - 0.5) * 5;
                        handleMiss(true);
                    }
                }

                // Out of bounds
                if (ball.x > canvas.width || ball.y < 0 || ball.y > canvas.height) {
                    if (gameState === 'shooting') handleMiss(false);
                }

                ball.velocityX *= 0.995;
                ball.velocityY *= 0.995;
            }

            // Update Alisson
            if (alisson.diving) {
                alisson.diveFrame++;
                const targetY = Math.max(goal.y, Math.min(goal.y + goal.height - alisson.height, alisson.targetY));
                alisson.y += (targetY - alisson.y) * 0.15;
            } else if (gameState === 'playing') {
                const targetY = ball.y - alisson.height / 2;
                const clampedTarget = Math.max(goal.y, Math.min(goal.y + goal.height - alisson.height, targetY));
                alisson.y += (clampedTarget - alisson.y) * level.keeperSpeed;
            }

            if (salah.kickFrame > 0) salah.kickFrame--;
            if (salah.celebrating) salah.celebrateFrame++;
        }

        function gameLoop() {
            updateGame();

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Screen shake effect
            ctx.save();
            if (screenShake > 0) {
                const shakeX = (Math.random() - 0.5) * screenShake;
                const shakeY = (Math.random() - 0.5) * screenShake;
                ctx.translate(shakeX, shakeY);
                screenShake *= 0.9;
                if (screenShake < 0.5) screenShake = 0;
            }

            const level = levels[currentLevel];

            // FPV mode for free kicks
            if (level?.freeKick && (gameState === 'freeKick' || freeKickPhase === 'flying')) {
                // Update FPV free kick logic
                updateFPVFreeKick();
                // Draw FPV view
                drawFPVFreeKick();
                // Draw celebration overlay if celebrating
                drawCelebration();
            } else {
                // Normal game view
                drawField();

                // Draw defenders
                if (level && !level.freeKick) {
                    level.defenders.forEach(defName => {
                        const def = defenders[defName];
                        if (def) drawDefender(def.x, def.y, def.number, def.skin);
                    });
                }

                drawSalah(salah.x, salah.y);
                drawAlisson(alisson.x, alisson.y, alisson.diving, alisson.diveDirection);
                drawBall();
                drawPowerMeter();
                drawCelebration();
                drawTip();
            }

            // Draw streak counter if on a streak - centered at top to avoid lives
            if (currentStreak >= 2 && gameState !== 'menu') {
                const streakText = `üî• x${currentStreak}`;
                const comboText = comboMultiplier > 1 ? ` (${comboMultiplier}x)` : '';
                ctx.font = 'bold 14px monospace';
                const fullText = streakText + comboText;
                const textWidth = ctx.measureText(fullText).width + 20;
                const streakX = (canvas.width / 2) - (textWidth / 2);

                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(streakX, 5, textWidth, 25);
                ctx.fillStyle = currentStreak >= 5 ? '#ff4444' : currentStreak >= 3 ? '#ffd700' : '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(fullText, canvas.width / 2, 22);
                ctx.textAlign = 'left';
            }

            // Draw pause overlay with big play button
            if (gamePaused && gameState !== 'menu' && gameState !== 'gameOver') {
                // Gray overlay
                ctx.fillStyle = 'rgba(0,0,0,0.75)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Big play button circle
                const btnX = canvas.width / 2;
                const btnY = canvas.height / 2;
                const btnRadius = 60;

                // Button background
                ctx.beginPath();
                ctx.arc(btnX, btnY, btnRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#c8102e';
                ctx.fill();
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 4;
                ctx.stroke();

                // Play triangle
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(btnX - 15, btnY - 25);
                ctx.lineTo(btnX - 15, btnY + 25);
                ctx.lineTo(btnX + 25, btnY);
                ctx.closePath();
                ctx.fill();

                // Text
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 24px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', btnX, btnY - 90);
                ctx.font = '10px "Press Start 2P", monospace';
                ctx.fillStyle = '#fff';
                ctx.fillText('TAP TO PLAY', btnX, btnY + 90);
                ctx.textAlign = 'left';
            }

            ctx.restore();

            requestAnimationFrame(gameLoop);
        }

        // Draw tips at bottom of screen
        function drawTip() {
            if (gameState === 'playing' || gameState === 'freeKick') {
                tipTimer++;
                if (tipTimer > 600) { // Change tip every 10 seconds
                    tipTimer = 0;
                    currentTip = (currentTip + 1) % tips.length;
                }

                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, canvas.height - 25, canvas.width, 25);
                ctx.fillStyle = '#ffd700';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(tips[currentTip], canvas.width / 2, canvas.height - 8);
                ctx.textAlign = 'left';
            }
        }

        // Intro scene
        const introCanvas = document.getElementById('introCanvas');
        const introCtx = introCanvas ? introCanvas.getContext('2d') : null;

        let introKeeperY = 150; // Keeper position for diving
        let introKeeperDiving = false;

        function drawIntroScene() {
            if (!introCtx) return;
            introCtx.fillStyle = '#2d5a27';
            introCtx.fillRect(0, 0, 400, 300);

            // Grass stripes
            introCtx.fillStyle = '#347a2c';
            for (let i = 0; i < 400; i += 40) introCtx.fillRect(i, 0, 20, 300);

            // Goal posts
            introCtx.fillStyle = '#fff';
            introCtx.fillRect(350, 100, 6, 100); // Left post
            introCtx.fillRect(350, 100, 45, 6);   // Crossbar
            introCtx.fillRect(350, 194, 45, 6);   // Bottom bar

            // Net (behind goal)
            introCtx.strokeStyle = 'rgba(255,255,255,0.4)';
            introCtx.lineWidth = 1;
            for (let i = 105; i < 195; i += 10) {
                introCtx.beginPath();
                introCtx.moveTo(356, i);
                introCtx.lineTo(390, i);
                introCtx.stroke();
            }
            for (let i = 360; i < 395; i += 10) {
                introCtx.beginPath();
                introCtx.moveTo(i, 105);
                introCtx.lineTo(i, 195);
                introCtx.stroke();
            }

            // Draw pixel Salah based on phase
            const salahX = Math.min(introBallX - 20, 280);

            if (introPhase === 'run' || introPhase === 'kick') {
                // Running Salah
                const bounce = Math.sin(introFrame * 0.3) * 3;
                introCtx.fillStyle = '#1a1a1a';
                introCtx.fillRect(salahX + 4, 135 + bounce, 16, 8);
                introCtx.fillStyle = '#c68642';
                introCtx.fillRect(salahX + 6, 140 + bounce, 12, 12);
                introCtx.fillStyle = '#c8102e';
                introCtx.fillRect(salahX + 4, 152 + bounce, 16, 14);
                introCtx.fillStyle = '#c68642';
                introCtx.fillRect(salahX + 6, 166 + bounce, 5, 8);
                introCtx.fillRect(salahX + 13, 166 + bounce, 5, 8);
            }

            if (introPhase === 'goal' || introPhase === 'celebrate') {
                // Celebrating Salah - sliding on knees with arms up
                const pump = Math.sin(introFrame * 0.15) * 3;
                introCtx.fillStyle = '#1a1a1a';
                introCtx.fillRect(salahX + 4, 145, 16, 8); // Hair
                introCtx.fillStyle = '#c68642';
                introCtx.fillRect(salahX + 6, 150, 12, 12); // Face
                introCtx.fillStyle = '#c8102e';
                introCtx.fillRect(salahX + 4, 162, 16, 14); // Body
                // Arms raised in celebration
                introCtx.fillRect(salahX - 4, 150 - pump, 8, 14);
                introCtx.fillRect(salahX + 20, 150 + pump, 8, 14);
                // Kneeling legs
                introCtx.fillStyle = '#c68642';
                introCtx.fillRect(salahX + 4, 176, 16, 6);
            }

            // Keeper (Alisson) - diving/defeated
            if (introPhase === 'goal' || introPhase === 'celebrate') {
                // Alisson on knees, defeated
                introCtx.fillStyle = '#32CD32';
                introCtx.fillRect(338, 175, 20, 12); // Body lying
                introCtx.fillStyle = '#d4a574';
                introCtx.fillRect(335, 175, 8, 8); // Head down
                introCtx.fillStyle = '#FFD700'; // Gloves
                introCtx.fillRect(330, 180, 6, 6);
                introCtx.fillRect(356, 180, 6, 6);
            } else if (introPhase === 'kick') {
                // Alisson diving (wrong way!)
                introCtx.fillStyle = '#32CD32';
                introCtx.fillRect(335, introKeeperY + 20, 18, 10); // Diving body
                introCtx.fillStyle = '#d4a574';
                introCtx.fillRect(337, introKeeperY + 15, 8, 8); // Head
                introCtx.fillStyle = '#FFD700';
                introCtx.fillRect(332, introKeeperY + 10, 8, 10); // Gloves reaching
            } else {
                // Standing ready
                introCtx.fillStyle = '#32CD32';
                introCtx.fillRect(338, 135, 12, 30);
                introCtx.fillStyle = '#d4a574';
                introCtx.fillRect(340, 128, 8, 10);
                introCtx.fillStyle = '#FFD700';
                introCtx.fillRect(334, 138, 6, 8);
                introCtx.fillRect(348, 138, 6, 8);
            }

            // Ball - at Salah's feet during run, then flying during kick/goal
            let ballDrawX, ballDrawY;
            if (introPhase === 'run') {
                // Ball at Salah's feet while dribbling
                const bounce = Math.sin(introFrame * 0.3) * 3;
                ballDrawX = salahX + 18; // At his feet
                ballDrawY = 172 + bounce; // Bouncing with him
            } else {
                ballDrawX = introBallX;
                ballDrawY = introBallY;
            }

            introCtx.fillStyle = '#fff';
            introCtx.beginPath();
            introCtx.arc(ballDrawX, ballDrawY, 6, 0, Math.PI * 2);
            introCtx.fill();
            introCtx.fillStyle = '#333';
            introCtx.beginPath();
            introCtx.arc(ballDrawX - 2, ballDrawY - 2, 2, 0, Math.PI * 2);
            introCtx.fill();

            // Title
            introCtx.fillStyle = '#c8102e';
            introCtx.font = 'bold 20px monospace';
            introCtx.textAlign = 'center';
            introCtx.fillText('MO SALAH', 200, 40);
            introCtx.fillStyle = '#ffd700';
            introCtx.font = '14px monospace';
            introCtx.fillText('GOAL MACHINE', 200, 60);
            introCtx.textAlign = 'left';

            if (introPhase === 'goal' || introPhase === 'celebrate') {
                // Net bulge effect - ball is IN the net
                introCtx.fillStyle = 'rgba(255,215,0,0.3)';
                introCtx.fillRect(0, 0, 400, 300);

                // GOAL text
                introCtx.fillStyle = '#ffd700';
                introCtx.font = 'bold 28px monospace';
                introCtx.textAlign = 'center';
                introCtx.strokeStyle = '#000';
                introCtx.lineWidth = 3;
                introCtx.strokeText('GOAL!', 200, 250);
                introCtx.fillText('GOAL!', 200, 250);

                // Confetti
                for (let i = 0; i < 15; i++) {
                    introCtx.fillStyle = ['#c8102e', '#ffd700', '#fff'][i % 3];
                    const cx = (introFrame * 2 + i * 30) % 400;
                    const cy = (introFrame + i * 20) % 300;
                    introCtx.fillRect(cx, cy, 4, 4);
                }
                introCtx.textAlign = 'left';
            }
        }

        function updateIntro() {
            introFrame++;

            if (introPhase === 'run') {
                introBallX += 1.5;
                // Ball stays at Salah's feet during dribbling
                introBallY = 170 + Math.sin(introFrame * 0.4) * 2; // Slight dribble bounce
                if (introBallX > 300) {
                    introPhase = 'kick';
                    introKeeperDiving = true;
                }
            } else if (introPhase === 'kick') {
                introBallX += 5;
                // Ball curves into top corner
                introBallY = 150 + Math.sin((introBallX - 300) * 0.03) * -30;
                // Keeper dives wrong way
                if (introKeeperDiving) {
                    introKeeperY += 2; // Diving down while ball goes up!
                }
                // Ball reaches inside the goal (past the posts)
                if (introBallX > 375) {
                    introPhase = 'goal';
                    introBallX = 375; // Ball rests in back of net
                    introBallY = 130; // Top corner
                    setTimeout(() => { introPhase = 'celebrate'; }, 1500);
                }
            } else if (introPhase === 'celebrate') {
                if (introFrame > 500) {
                    skipIntro();
                }
            }
        }

        function introLoop() {
            if (!introActive) return;
            updateIntro();
            drawIntroScene();
            requestAnimationFrame(introLoop);
        }

        function skipIntro() {
            introActive = false;
            document.getElementById('introOverlay').classList.add('hidden');
            document.getElementById('startOverlay').classList.remove('hidden');
        }

        // Skip intro on button click or key press
        document.getElementById('skipIntroBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            skipIntro();
        });
        document.getElementById('skipIntroBtn').addEventListener('touchstart', (e) => {
            e.stopPropagation();
            skipIntro();
        });
        document.addEventListener('keydown', () => { if (introActive) skipIntro(); });

        // Menu handlers
        document.getElementById('startBtn').addEventListener('click', () => {
            playerName = document.getElementById('playerName').value.trim() || 'PLAYER';
            document.getElementById('startOverlay').classList.add('hidden');
            totalScore = 0;
            lives = 5;
            currentStreak = 0;
            bestStreak = 0;
            comboMultiplier = 1;
            deathCount = 0;
            document.getElementById('totalScore').textContent = '0';
            startLevel(0);
        });

        document.getElementById('nextLevelBtn').addEventListener('click', () => {
            // Show ad between levels (every other level for better UX)
            if (currentLevel > 0 && currentLevel % 2 === 0) {
                showAd(() => {
                    startLevel(currentLevel + 1);
                });
            } else {
                startLevel(currentLevel + 1);
            }
        });

        document.getElementById('extraLifeBtn').addEventListener('click', () => {
            showRewardedAd(() => {
                lives++;
                // STREAK PENALTY: Using ad life resets your current streak!
                const hadStreak = currentStreak >= 2;
                currentStreak = 0;
                comboMultiplier = 1;
                // Pause game after ad so player can prepare
                setTimeout(() => {
                    gamePaused = true;
                    document.getElementById('pauseBtn').textContent = '‚ñ∂';
                    const msg = hadStreak ? '+1 LIFE! (Streak reset) Tap ‚ñ∂ when ready!' : '+1 LIFE! Tap ‚ñ∂ when ready!';
                    document.getElementById('message').textContent = msg;
                }, 100);
            });
        });

        document.getElementById('continueAdBtn').addEventListener('click', () => {
            showRewardedAd(() => {
                // Give player another chance - but streak resets as penalty
                document.getElementById('gameOverOverlay').classList.add('hidden');
                lives = 1;
                // STREAK PENALTY: Using ad to continue resets streak!
                currentStreak = 0;
                comboMultiplier = 1;
                resetPositions();
                // Pause so they can prepare
                setTimeout(() => {
                    gamePaused = true;
                    document.getElementById('pauseBtn').textContent = '‚ñ∂';
                    document.getElementById('message').textContent = 'Streak reset! Tap ‚ñ∂ to continue!';
                }, 100);
            });
        });

        document.getElementById('playAgainBtn').addEventListener('click', () => {
            // Show ad on replay
            showAd(() => {
                document.getElementById('gameOverOverlay').classList.add('hidden');
                totalScore = 0;
                lives = 5;
                currentStreak = 0;
                bestStreak = 0;
                comboMultiplier = 1;
                deathCount = 0;
                document.getElementById('totalScore').textContent = '0';
                startLevel(0);
            });
        });

        document.getElementById('mainMenuBtn').addEventListener('click', () => {
            document.getElementById('gameOverOverlay').classList.add('hidden');
            document.getElementById('startOverlay').classList.remove('hidden');
            displayLeaderboard('leaderboard');
        });

        // Initialize
        document.getElementById('startOverlay').classList.add('hidden'); // Hide until intro done
        displayLeaderboard('leaderboard');
        introLoop(); // Start intro
        gameLoop();
    </script>
</body>
</html>
