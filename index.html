<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1a1a2e">
    <title>Mo Salah Goal Machine</title>

    <!-- Open Graph / Facebook / WhatsApp -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://mosalahgame.com/">
    <meta property="og:title" content="Mo Salah Goal Machine">
    <meta property="og:description" content="Play as Mo Salah and score goals! Dodge defenders, take free kicks, and become a legend. Can you beat my score? ‚öΩüèÜ">
    <meta property="og:image" content="https://placehold.co/1200x630/c8102e/ffd700?text=MO+SALAH%0AGOAL+MACHINE%0A‚öΩ+Play+Now!&font=montserrat">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Mo Salah Goal Machine">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://mosalahgame.com/">
    <meta property="twitter:title" content="Mo Salah Goal Machine">
    <meta property="twitter:description" content="Play as Mo Salah and score goals! Dodge defenders, take free kicks, and become a legend.">
    <meta property="twitter:image" content="https://placehold.co/1200x630/c8102e/ffd700?text=MO+SALAH%0AGOAL+MACHINE%0A‚öΩ+Play+Now!&font=montserrat">
    <!-- GameMonetize SDK for Ads -->
    <script src="https://api.gamemonetize.com/sdk.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Press Start 2P', monospace;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .game-container {
            text-align: center;
            padding: 5px;
            width: 100%;
            max-width: 100vw;
            max-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        h1 {
            color: #c8102e;
            font-size: clamp(12px, 4vw, 20px);
            margin-bottom: 5px;
            text-shadow: 2px 2px 0 #000;
            font-family: 'Press Start 2P', monospace;
        }

        .score-board {
            display: flex;
            justify-content: center;
            gap: clamp(8px, 2vw, 20px);
            margin-bottom: 5px;
            font-family: 'Press Start 2P', monospace;
            flex-wrap: wrap;
        }

        .score {
            color: #fff;
            font-size: clamp(8px, 2.5vw, 12px);
        }

        .goals { color: #4ade80; }
        .saves { color: #f87171; }
        .level { color: #60a5fa; }
        .total { color: #ffd700; }

        #canvasWrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            border: 3px solid #c8102e;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(200, 16, 46, 0.5);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            touch-action: none;
            max-width: 100%;
            height: auto;
        }

        .pause-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #ffd700;
            color: #ffd700;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            z-index: 50;
            font-family: 'Press Start 2P', monospace;
        }
        .pause-btn:active {
            background: rgba(255,215,0,0.3);
        }

        .sound-btn {
            position: absolute;
            top: 10px;
            right: 55px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #ffd700;
            color: #ffd700;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            z-index: 50;
            font-family: 'Press Start 2P', monospace;
        }
        .sound-btn:active {
            background: rgba(255,215,0,0.3);
        }
        .sound-btn.sound-off {
            opacity: 0.5;
        }

        .instructions {
            color: #888;
            font-size: clamp(6px, 1.5vw, 8px);
            margin-top: 5px;
            font-family: 'Press Start 2P', monospace;
            line-height: 1.6;
        }

        .mobile-controls {
            display: none;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            padding: 0 10px;
            width: 100%;
            max-width: 800px;
            flex-shrink: 0;
        }

        @media (pointer: coarse) {
            .mobile-controls { display: flex; }
            .instructions { display: none; }
        }

        .joystick-area {
            width: clamp(70px, 15vw, 120px);
            height: clamp(70px, 15vw, 120px);
            background: rgba(255,255,255,0.15);
            border-radius: 50%;
            position: relative;
            border: 3px solid rgba(255,255,255,0.4);
            flex-shrink: 0;
        }

        .joystick-knob {
            width: 45%;
            height: 45%;
            background: rgba(200, 16, 46, 0.9);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid #fff;
        }

        .shoot-btn {
            width: clamp(60px, 14vw, 100px);
            height: clamp(60px, 14vw, 100px);
            background: linear-gradient(145deg, #c8102e, #a00d24);
            border-radius: 50%;
            border: 4px solid #ffd700;
            color: #fff;
            font-family: 'Press Start 2P', monospace;
            font-size: clamp(8px, 2vw, 12px);
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(200, 16, 46, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        /* Landscape mobile - FULL SCREEN canvas with overlay controls */
        @media (orientation: landscape) and (max-height: 500px) {
            .game-container {
                padding: 0;
                justify-content: center;
                align-items: center;
            }
            #canvasWrapper {
                width: 100vw;
                height: 100vh;
                max-width: none;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            #gameCanvas {
                max-height: 100vh !important;
                max-width: 100vw !important;
                object-fit: contain;
            }
            .mobile-controls {
                display: flex !important;
                position: fixed;
                bottom: 10px;
                left: 0;
                right: 0;
                justify-content: space-between;
                padding: 0 15px;
                background: transparent;
                pointer-events: none;
                z-index: 100;
            }
            .mobile-controls > * {
                pointer-events: auto;
            }
            .joystick-area {
                width: 100px;
                height: 100px;
            }
            .shoot-btn {
                width: 80px;
                height: 80px;
                font-size: 12px;
            }
            /* Hide UI elements - info is on canvas */
            h1, .score-board, .message, .instructions {
                display: none !important;
            }
        }

        /* Portrait mobile - stack vertically */
        @media (orientation: portrait) and (max-width: 600px) {
            .game-container {
                padding: 5px;
                justify-content: flex-start;
                padding-top: env(safe-area-inset-top, 10px);
            }
            h1 { font-size: 14px; margin-bottom: 3px; }
            .score-board { gap: 10px; margin-bottom: 3px; }
            .score { font-size: 9px; }
            .mobile-controls {
                margin-top: 8px;
                padding: 0 15px;
            }
        }

        /* Very small screens */
        @media (max-width: 380px) {
            h1 { font-size: 11px; }
            .score { font-size: 7px; }
            .joystick-area { width: 65px; height: 65px; }
            .shoot-btn { width: 55px; height: 55px; font-size: 7px; }
        }

        /* Large screens / desktop */
        @media (min-width: 1024px) {
            .game-container { padding: 20px; }
            h1 { font-size: 24px; }
            .score { font-size: 14px; }
        }

        .message {
            color: #ffd700;
            font-size: 11px;
            margin-top: 10px;
            font-family: 'Press Start 2P', monospace;
            min-height: 20px;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .overlay.hidden { display: none; }

        .menu {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 4px solid #c8102e;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .menu h2 {
            color: #c8102e;
            font-size: 18px;
            margin-bottom: 20px;
            font-family: 'Press Start 2P', monospace;
        }

        .menu input {
            padding: 12px;
            font-size: 14px;
            font-family: 'Press Start 2P', monospace;
            border: 3px solid #c8102e;
            border-radius: 8px;
            margin: 10px 0;
            width: 200px;
            text-align: center;
        }

        .menu button {
            padding: 15px 30px;
            font-size: 12px;
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(145deg, #c8102e, #a00d24);
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.1s;
        }

        .menu button:hover {
            transform: scale(1.05);
        }

        .leaderboard {
            margin-top: 20px;
            text-align: left;
        }

        .leaderboard h3 {
            color: #ffd700;
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
        }

        .leaderboard-entry {
            color: #fff;
            font-size: 10px;
            padding: 5px 0;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
        }

        .leaderboard-entry.gold { color: #ffd700; }
        .leaderboard-entry.silver { color: #c0c0c0; }
        .leaderboard-entry.bronze { color: #cd7f32; }

        /* Force GameMonetize ads to appear ABOVE game overlays */
        #GameMonetize-container,
        [id*="GameMonetize"],
        [class*="gamemonetize"],
        iframe[src*="gamemonetize"],
        div[style*="z-index: 99999"],
        div[style*="z-index:99999"] {
            z-index: 999999 !important;
        }

        /* When ad is playing, hide our overlays */
        body.ad-playing .overlay {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>MO SALAH GOAL MACHINE</h1>
        <div class="score-board">
            <span class="score level">LVL: <span id="level">1</span>/<span id="totalLevels">9</span></span>
            <span class="score goals">GOALS: <span id="goals">0</span>/<span id="target">2</span></span>
            <span class="score total">PTS: <span id="totalScore">0</span></span>
        </div>
        <div id="canvasWrapper">
            <canvas id="gameCanvas" width="800" height="500"></canvas>
            <button class="sound-btn sound-off" id="soundBtn" title="Music">‚ô™</button>
            <button class="pause-btn" id="pauseBtn" title="Pause">‚ùö‚ùö</button>
        </div>
        <div class="message" id="message">Hold SHOOT to power up!</div>
        <div class="instructions">
            ARROWS/WASD - Move | HOLD SPACE - Power shot | Avoid defenders!
        </div>
        <div class="mobile-controls">
            <div class="joystick-area" id="joystick">
                <div class="joystick-knob" id="knob"></div>
            </div>
            <button class="shoot-btn" id="shootBtn">SHOOT</button>
        </div>
    </div>

    <!-- Start Menu Overlay -->
    <div class="overlay hidden" id="startOverlay">
        <div class="menu">
            <h2>MO SALAH<br>GOAL MACHINE</h2>
            <p style="color:#fff;font-size:10px;margin:15px 0;">Enter your name:</p>
            <input type="text" id="playerName" placeholder="YOUR NAME" maxlength="12">
            <br>
            <button id="startBtn">START GAME</button>
            <div class="leaderboard" id="leaderboard"></div>
        </div>
    </div>

    <!-- Ad Container -->
    <div class="overlay hidden" id="adOverlay">
        <div class="menu" style="padding:20px;min-width:280px;">
            <p style="color:#ffd700;font-size:14px;margin-bottom:10px;" id="adTitle">BONUS INCOMING!</p>
            <p style="color:#fff;font-size:24px;margin:20px 0;" id="adCountdown">5</p>
            <div id="gamemonetize-ad" style="min-height:80px;display:flex;align-items:center;justify-content:center;">
                <div style="color:#888;font-size:10px;" id="adStatus">Loading...</div>
            </div>
            <button id="closeAdBtn" style="margin-top:15px;padding:10px 20px;font-size:10px;background:#666;display:none;">SKIP</button>
        </div>
    </div>

    <!-- Level Complete Overlay -->
    <div class="overlay hidden" id="levelOverlay">
        <div class="menu">
            <h2 id="levelTitle">LEVEL COMPLETE!</h2>
            <p style="color:#4ade80;font-size:14px;margin:15px 0;" id="levelScore"></p>
            <p style="color:#fff;font-size:10px;margin:15px 0;" id="levelDesc"></p>
            <button id="nextLevelBtn">NEXT LEVEL</button>
            <button id="extraLifeBtn" style="background:linear-gradient(145deg,#22c55e,#16a34a);margin-top:5px;">üì∫ WATCH AD +1 LIFE</button>
        </div>
    </div>

    <!-- Game Over Overlay -->
    <div class="overlay hidden" id="gameOverOverlay">
        <div class="menu">
            <h2>GAME OVER</h2>
            <p style="color:#ffd700;font-size:16px;margin:15px 0;">Final Score: <span id="finalScore">0</span></p>
            <p style="color:#ff6b6b;font-size:12px;margin:5px 0;" id="bestStreakDisplay"></p>
            <p style="color:#fff;font-size:10px;margin:15px 0;" id="gameOverMsg"></p>
            <div style="margin:15px 0;">
                <p style="color:#fff;font-size:8px;margin-bottom:8px;">SHARE YOUR SCORE:</p>
                <button onclick="shareScore('x')" style="padding:8px 12px;font-size:10px;margin:3px;background:#000;">ùïè Post</button>
                <button onclick="shareScore('facebook')" style="padding:8px 12px;font-size:10px;margin:3px;background:#1877F2;">üìò Facebook</button>
                <button onclick="shareScore('whatsapp')" style="padding:8px 12px;font-size:10px;margin:3px;background:#25D366;">üí¨ WhatsApp</button>
                <button onclick="shareScore('copy')" style="padding:8px 12px;font-size:10px;margin:3px;background:#666;">üìã Copy</button>
                <button onclick="generateScoreCard()" style="padding:8px 12px;font-size:10px;margin:3px;background:#c8102e;">üì∏ Save Card</button>
            </div>
            <button id="continueAdBtn" style="background:linear-gradient(145deg,#22c55e,#16a34a);">üì∫ WATCH AD TO CONTINUE</button>
            <button id="playAgainBtn">PLAY AGAIN</button>
            <button id="mainMenuBtn">MAIN MENU</button>
            <div class="leaderboard" id="gameOverLeaderboard"></div>
        </div>
    </div>

    <!-- Intro Overlay -->
    <div class="overlay" id="introOverlay">
        <div style="text-align:center;">
            <canvas id="introCanvas" width="400" height="300" style="border-radius:8px;"></canvas>
            <button id="skipIntroBtn" style="margin-top:20px;padding:15px 40px;font-size:14px;font-family:'Press Start 2P',monospace;background:linear-gradient(145deg,#c8102e,#a00d24);color:#fff;border:4px solid #ffd700;border-radius:8px;cursor:pointer;animation:pulse 1s infinite;">SKIP INTRO</button>
        </div>
    </div>
    <style>
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px #ffd700; }
            50% { transform: scale(1.05); box-shadow: 0 0 20px #ffd700; }
        }
    </style>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ========== MO SALAH MUSIC (Web Audio API) ==========
        let audioCtx = null;
        let musicPlaying = false;
        let musicInterval = null;

        // "Mo Salah" melody (inspired by "Sit Down" by James)
        // Notes: Mo Sa-lah, Mo Sa-lah, Mo Sa-lah, running down the wing
        const moSalahMelody = [
            { note: 'E4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'D4', duration: 0.6 },
            { note: 'E4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'D4', duration: 0.6 },
            { note: 'E4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'D4', duration: 0.3 },
            { note: 'C4', duration: 0.3 },
            { note: 'D4', duration: 0.3 },
            { note: 'E4', duration: 0.6 },
            // "Sa-lah la la la la"
            { note: 'G4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'D4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'D4', duration: 0.3 },
            { note: 'C4', duration: 0.6 },
            // "The Egyptian King"
            { note: 'E4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'G4', duration: 0.3 },
            { note: 'E4', duration: 0.3 },
            { note: 'D4', duration: 0.6 },
            { note: 'rest', duration: 0.6 },
        ];

        const noteFrequencies = {
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
            'G4': 392.00, 'A4': 440.00, 'B4': 493.88, 'C5': 523.25,
            'rest': 0
        };

        function playNote(frequency, duration, startTime) {
            if (!audioCtx || frequency === 0) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'square'; // 8-bit style sound
            oscillator.frequency.value = frequency;

            // Envelope for nicer sound
            gainNode.gain.setValueAtTime(0.15, startTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration * 0.9);

            oscillator.start(startTime);
            oscillator.stop(startTime + duration);
        }

        function playMoSalahSong() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }

            let time = audioCtx.currentTime + 0.1;
            moSalahMelody.forEach(({ note, duration }) => {
                const freq = noteFrequencies[note];
                if (freq > 0) {
                    playNote(freq, duration, time);
                }
                time += duration;
            });

            // Return total duration for looping
            return moSalahMelody.reduce((sum, n) => sum + n.duration, 0) * 1000;
        }

        function toggleMusic() {
            const btn = document.getElementById('soundBtn');
            if (musicPlaying) {
                // Stop music
                musicPlaying = false;
                if (musicInterval) clearInterval(musicInterval);
                if (audioCtx) audioCtx.suspend();
                btn.classList.add('sound-off');
                btn.title = 'Music Off';
            } else {
                // Start music - MUST resume AudioContext on mobile
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                // Resume if suspended (required on mobile)
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                musicPlaying = true;
                btn.classList.remove('sound-off');
                btn.title = 'Music On';
                const songLength = playMoSalahSong();
                musicInterval = setInterval(() => {
                    if (musicPlaying && audioCtx.state === 'running') {
                        playMoSalahSong();
                    }
                }, songLength + 500); // Small gap between loops
            }
        }

        document.getElementById('soundBtn')?.addEventListener('click', toggleMusic);

        // ========== RESPONSIVE SCALING ==========
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 500;
        let canvasScale = 1;

        function resizeCanvas() {
            const wrapper = document.getElementById('canvasWrapper');
            const container = document.querySelector('.game-container');
            const isLandscape = window.innerWidth > window.innerHeight && window.innerHeight < 500;

            let maxWidth, maxHeight;

            if (isLandscape) {
                // Landscape: fill screen, leave small margin for controls
                maxWidth = window.innerWidth - 40;
                maxHeight = window.innerHeight - 20; // Minimal margin
            } else {
                // Portrait: leave room for UI elements
                maxWidth = Math.min(window.innerWidth - 20, 800);
                maxHeight = window.innerHeight - 200;
            }

            // Calculate scale to fit
            const scaleX = maxWidth / GAME_WIDTH;
            const scaleY = maxHeight / GAME_HEIGHT;
            canvasScale = Math.min(scaleX, scaleY, 1.5); // Allow scaling up to 1.5x in landscape

            // Apply size via CSS (keeps internal resolution)
            canvas.style.width = (GAME_WIDTH * canvasScale) + 'px';
            canvas.style.height = (GAME_HEIGHT * canvasScale) + 'px';

            // Also resize intro canvas
            const introCanvas = document.getElementById('introCanvas');
            if (introCanvas) {
                const introScale = Math.min(canvasScale * 1.2, 1);
                introCanvas.style.width = (400 * introScale) + 'px';
                introCanvas.style.height = (300 * introScale) + 'px';
            }
        }

        // Pause toggle
        let pauseDebounce = 0;

        function togglePause() {
            if (gameState === 'menu' || gameState === 'gameOver' || gameState === 'levelComplete') return;

            // Debounce to prevent accidental rapid toggling
            if (Date.now() - pauseDebounce < 300) return;
            pauseDebounce = Date.now();

            gamePaused = !gamePaused;
            const pauseBtn = document.getElementById('pauseBtn');
            if (gamePaused) {
                pauseBtn.textContent = '‚ñ∂';
                document.getElementById('message').textContent = 'PAUSED - Tap ‚ñ∂ to resume';
            } else {
                pauseBtn.textContent = '‚ùö‚ùö';
                document.getElementById('message').textContent = 'Hold SHOOT to power up!';
            }
        }

        document.getElementById('pauseBtn')?.addEventListener('click', togglePause);

        // Tap canvas to unpause (when paused) or lock free kick target
        canvas.addEventListener('click', (e) => {
            if (gamePaused && gameState !== 'menu' && gameState !== 'gameOver') {
                togglePause();
            } else if (gameState === 'freeKick' && freeKickPhase === 'aim') {
                // Tap to lock target, same as pressing shoot button
                handleShootPress();
            }
        });
        canvas.addEventListener('touchend', (e) => {
            if (gamePaused && gameState !== 'menu' && gameState !== 'gameOver') {
                e.preventDefault();
                togglePause();
            }
            // Free kick tap handled by shoot button
        });

        // Handle resize and orientation changes
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100); // Delay for orientation to settle
        });

        // Prevent unwanted touch behaviors
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('.overlay input')) return; // Allow scrolling in inputs
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('gesturestart', (e) => e.preventDefault());
        document.addEventListener('gesturechange', (e) => e.preventDefault());

        // Initial resize
        resizeCanvas();

        // ========== LEVEL CONFIGURATIONS ==========
        // Level configurations - easier start, gradual difficulty
        const levels = [
            { name: "Warm Up", target: 2, defenders: [], keeperSpeed: 0.012, desc: "Just you and Alisson. Easy start!" },
            { name: "Getting Started", target: 2, defenders: ['konate'], keeperSpeed: 0.015, defenderSpeed: 2.0, desc: "Konate joins but he's taking it easy!" },
            { name: "Van Dijk!", target: 2, defenders: ['konate', 'vandijk'], keeperSpeed: 0.018, defenderSpeed: 2.3, desc: "The big man Van Dijk arrives!" },
            { name: "Robertson Joins", target: 3, defenders: ['konate', 'vandijk', 'robertson'], keeperSpeed: 0.022, defenderSpeed: 2.5, desc: "Robertson adds to the defense!" },
            { name: "FREE KICK!", target: 1, defenders: [], keeperSpeed: 0.025, freeKick: true, wallSize: 3, desc: "Bonus Round! Bend it like Salah!" },
            { name: "Stepping Up", target: 3, defenders: ['konate', 'vandijk'], keeperSpeed: 0.028, defenderSpeed: 2.8, desc: "Defenders are getting serious!" },
            { name: "Full Squad", target: 3, defenders: ['konate', 'vandijk', 'robertson', 'bradley'], keeperSpeed: 0.032, defenderSpeed: 3.0, desc: "Bradley completes the back four!" },
            { name: "FINAL FREE KICK", target: 1, defenders: [], keeperSpeed: 0.035, freeKick: true, wallSize: 4, desc: "Bigger wall! Curve it in!" },
            { name: "SUDDEN DEATH", target: 999, defenders: ['konate', 'vandijk', 'robertson', 'bradley'], keeperSpeed: 0.04, defenderSpeed: 3.3, suddenDeath: true, desc: "ENDLESS MODE! Score until you drop!" }
        ];

        // Game state
        let currentLevel = 0;
        let levelGoals = 0;
        let totalScore = 0;
        let lives = 5;
        let playerName = '';
        let gameState = 'menu'; // menu, playing, shooting, celebrating, saved, tackled, freeKick, gameOver
        let gamePaused = false; // Pause game during ads/overlays

        // Combo/streak system
        let currentStreak = 0;
        let bestStreak = 0;
        let comboMultiplier = 1;
        let screenShake = 0;
        let lastGoalTime = 0;
        let deathCount = 0; // Track deaths for ad breaks

        // Free kick state - Moving target system
        let freeKickPhase = 'aim'; // aim, power, flying, done
        let fkTargetX = 400; // Moving target X position
        let fkTargetDir = 1; // Target movement direction
        let fkTargetSpeed = 3; // How fast target moves
        let fkBallPos = { x: 400, y: 400 }; // Ball position (2D for face-on view)
        let fkBallTarget = { x: 400, y: 150 }; // Where ball is heading
        let fkBallFlying = false;
        let fkPower = 0;
        let fkKeeperX = 400; // Keeper X position
        let fkKeeperDiving = false;
        let fkKeeperTargetX = 400;
        let fkResult = null; // 'goal', 'save', 'over', 'post', 'wide'

        // Salah (player)
        const salah = {
            x: 200, y: 250, width: 32, height: 48, speed: 4,
            hasBall: true, kickFrame: 0, celebrating: false, celebrateFrame: 0
        };

        // Ball
        const ball = {
            x: 220, y: 270, radius: 8,
            velocityX: 0, velocityY: 0, curve: 0, active: false
        };

        // Alisson
        const alisson = {
            x: 700, y: 250, width: 36, height: 52,
            targetY: 250, speed: 3, diving: false, diveDirection: 0, diveFrame: 0
        };

        // Defenders
        const defenders = {
            konate: { x: 500, y: 250, speed: 2.5, tackleRange: 35, number: 5, skin: '#3d2314' },
            vandijk: { x: 450, y: 180, speed: 2.2, tackleRange: 38, number: 4, skin: '#d4a574' },
            robertson: { x: 480, y: 320, speed: 2.8, tackleRange: 32, number: 26, skin: '#f5d5c8' },
            bradley: { x: 420, y: 250, speed: 2.6, tackleRange: 30, number: 66, skin: '#f5d5c8' }
        };

        // Goal
        // Goal - positioned for face-on view effect
        const goal = { x: 740, y: 130, width: 50, height: 240, postWidth: 10 };

        // Shot power
        let shotCharging = false;
        let shotPower = 0;
        let maxShotPower = 100;
        let chargeStartTime = 0;

        // Commentary
        const goalMessages = [
            'GOAL! The Egyptian King strikes!', 'SALAAAAH! What a finish!',
            'He makes it look so easy!', 'Running down the wing! SALAH!',
            'The Pharaoh has spoken!', 'Unstoppable from Mo Salah!',
            'Clinical finish! Pure class!', 'Alisson had no chance!',
            'WORLD CLASS!', 'The King of Egypt!'
        ];
        const saveMessages = [
            'SAVED by Alisson!', 'Great stop from Alisson!',
            'The Brazilian says NO!', 'Alisson stands tall!',
            'Denied by the keeper!', 'What a save! Alisson!'
        ];
        const missMessages = [
            'Over the bar! Too much power!', 'Blazed it over! So close!',
            'Into the stands!', 'Skied it!', 'Way too much on that one!'
        ];
        const tackleMessages = [
            'TACKLED!', 'Dispossessed!', 'Great defending!',
            'Ball won cleanly!', 'Reads it perfectly!'
        ];
        const freeKickMessages = [
            'WHAT A FREE KICK!', 'Bend it like Salah!',
            'Curled into the corner!', 'The wall had no chance!',
            'Absolutely magnificent!'
        ];
        const worldieMessages = [
            'WHAT A GOAL!!!', 'WORLDIE!!!', 'ABSOLUTE SCREAMER!!!',
            'FROM DOWNTOWN!!!', 'TOP BINS!!!', 'UNSTOPPABLE!!!',
            'ROCKET!!!', 'THUNDERBOLT!!!'
        ];

        // Worldie (long-range shot) state
        let isWorldieAttempt = false;
        let worldieGoalScored = false;

        // Slow-mo replay system
        const REPLAY_BUFFER_SIZE = 90; // ~1.5 seconds at 60fps
        let replayBuffer = [];
        let isRecording = true;
        let isReplaying = false;
        let replayFrame = 0;
        let replaySpeed = 0.15; // Slow-mo speed
        let replayType = null; // 'worldie', 'post_in', 'screamer'
        let pendingCelebration = null; // Store celebration to run after replay

        function recordFrame() {
            if (!isRecording || isReplaying) return;

            const frame = {
                ballX: ball.x,
                ballY: ball.y,
                ballVelX: ball.velocityX,
                ballVelY: ball.velocityY,
                keeperX: alisson.x,
                keeperY: alisson.y,
                keeperDiving: alisson.diving,
                keeperDiveDir: alisson.diveDirection,
                salahX: salah.x,
                salahY: salah.y,
                kickFrame: salah.kickFrame,
                gameState: gameState
            };

            replayBuffer.push(frame);
            if (replayBuffer.length > REPLAY_BUFFER_SIZE) {
                replayBuffer.shift();
            }
        }

        function startReplay(type) {
            if (replayBuffer.length < 20) return false; // Not enough frames

            isReplaying = true;
            isRecording = false;
            replayFrame = 0;
            replayType = type;
            return true;
        }

        function drawReplayFrame() {
            if (!isReplaying || replayBuffer.length === 0) return;

            const frameIndex = Math.floor(replayFrame);
            if (frameIndex >= replayBuffer.length) {
                // Replay done
                endReplay();
                return;
            }

            const frame = replayBuffer[frameIndex];
            const nextFrameIndex = Math.min(frameIndex + 1, replayBuffer.length - 1);
            const nextFrame = replayBuffer[nextFrameIndex];
            const t = replayFrame - frameIndex; // Interpolation factor

            // Lerp helper
            const lerp = (a, b, t) => a + (b - a) * t;

            // Draw darkened background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw pitch (simplified)
            ctx.fillStyle = '#2d5a27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#347a2c';
            for (let i = 0; i < 14; i++) {
                if (i % 2 === 0) ctx.fillRect(0, i * 35, canvas.width, 35);
            }

            // Draw goal
            ctx.fillStyle = '#fff';
            ctx.fillRect(goal.x, goal.y, goal.width, goal.postWidth);
            ctx.fillRect(goal.x, goal.y + goal.height - goal.postWidth, goal.width, goal.postWidth);
            ctx.fillRect(goal.x, goal.y, goal.postWidth, goal.height);
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo(goal.x, goal.y + i * 25);
                ctx.lineTo(goal.x + goal.width, goal.y + i * 25);
                ctx.stroke();
            }

            // Interpolated positions
            const ballX = lerp(frame.ballX, nextFrame.ballX, t);
            const ballY = lerp(frame.ballY, nextFrame.ballY, t);
            const keeperY = lerp(frame.keeperY, nextFrame.keeperY, t);

            // Draw Salah
            ctx.fillStyle = '#c8102e';
            ctx.fillRect(frame.salahX - 16, frame.salahY - 24, 32, 48);
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(frame.salahX - 8, frame.salahY - 36, 16, 16);
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.arc(frame.salahX, frame.salahY - 32, 10, Math.PI, 0);
            ctx.fill();

            // Draw keeper
            ctx.fillStyle = '#32CD32';
            if (frame.keeperDiving) {
                ctx.fillRect(alisson.x - 18, keeperY, 36, 52);
            } else {
                ctx.fillRect(alisson.x - 18, keeperY, 36, 52);
            }
            ctx.fillStyle = '#d4a574';
            ctx.fillRect(alisson.x - 8, keeperY - 12, 16, 16);

            // Draw ball with motion trail
            const trailLength = 8;
            for (let i = trailLength; i >= 0; i--) {
                const trailIdx = Math.max(0, frameIndex - i * 2);
                const trailFrame = replayBuffer[trailIdx];
                const alpha = (1 - i / trailLength) * 0.6;
                const size = ball.radius * (1 - i / trailLength * 0.5);

                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(trailFrame.ballX, trailFrame.ballY, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Main ball
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(ballX, ballY, ball.radius + 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(ballX - 3, ballY - 3, 4, 0, Math.PI * 2);
            ctx.fill();

            // Dramatic vignette
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 100,
                canvas.width / 2, canvas.height / 2, 400
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Scanlines effect (subtle CRT look)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            for (let y = 0; y < canvas.height; y += 4) {
                ctx.fillRect(0, y, canvas.width, 2);
            }

            // Cinematic letterbox (black bars top and bottom)
            const letterboxHeight = 40;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, letterboxHeight);
            ctx.fillRect(0, canvas.height - letterboxHeight, canvas.width, letterboxHeight);

            // Glowing border on worldie
            if (replayType === 'worldie') {
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                ctx.lineWidth = 6;
                ctx.strokeRect(3, letterboxHeight + 3, canvas.width - 6, canvas.height - letterboxHeight * 2 - 6);
            }

            // Replay label (in top letterbox)
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 18px monospace';
            ctx.textAlign = 'center';
            const replayText = replayType === 'worldie' ? 'üé¨ INSTANT REPLAY - WORLDIE!' :
                              replayType === 'post_in' ? 'üé¨ INSTANT REPLAY - OFF THE POST!' :
                              'üé¨ INSTANT REPLAY';
            ctx.fillText(replayText, canvas.width / 2, 26);

            // "SLOW MOTION" text with pulsing effect
            const pulse = 0.7 + Math.sin(Date.now() * 0.005) * 0.3;
            ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
            ctx.font = 'bold 12px monospace';
            ctx.fillText('‚óÄ‚óÄ SLOW MOTION ‚ñ∂‚ñ∂', canvas.width / 2, canvas.height - 15);

            // Progress bar (in bottom letterbox)
            const progress = frameIndex / replayBuffer.length;
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fillRect(150, canvas.height - 30, 500, 4);
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(150, canvas.height - 30, 500 * progress, 4);

            // Advance frame (slow-mo)
            replayFrame += replaySpeed;
        }

        function endReplay() {
            isReplaying = false;
            isRecording = true;
            replayBuffer = [];
            replayFrame = 0;
            replayType = null;

            // Now run the pending celebration
            if (pendingCelebration) {
                pendingCelebration();
                pendingCelebration = null;
            }
        }

        function randomMessage(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // Global Leaderboard using Dreamlo
        const DREAMLO_PRIVATE = 'plQDO2UdfEytCaRU9D0M3QjzvR1a9VJkaQBeFOXWkNUg';
        const DREAMLO_PUBLIC = '697e8e208f40bb1184cada44';
        let globalLeaderboard = [];

        async function fetchLeaderboard() {
            try {
                const response = await fetch(`https://www.dreamlo.com/lb/${DREAMLO_PUBLIC}/json`);
                const data = await response.json();
                if (data.dreamlo && data.dreamlo.leaderboard && data.dreamlo.leaderboard.entry) {
                    let entries = data.dreamlo.leaderboard.entry;
                    // Handle single entry (not array)
                    if (!Array.isArray(entries)) entries = [entries];
                    globalLeaderboard = entries.map(e => ({
                        name: e.name,
                        score: parseInt(e.score),
                        streak: parseInt(e.seconds) || 0 // Streak stored in seconds field
                    }));
                } else {
                    globalLeaderboard = [];
                }
            } catch (err) {
                console.log('Leaderboard fetch error:', err);
                // Fallback to local storage
                const data = localStorage.getItem('salahLeaderboard');
                globalLeaderboard = data ? JSON.parse(data) : [];
            }
            return globalLeaderboard;
        }

        async function saveScore(name, score) {
            // Save to local storage as backup
            const local = localStorage.getItem('salahLeaderboard');
            const leaderboard = local ? JSON.parse(local) : [];
            leaderboard.push({ name, score, streak: bestStreak, date: Date.now() });
            leaderboard.sort((a, b) => b.score - a.score);
            localStorage.setItem('salahLeaderboard', JSON.stringify(leaderboard.slice(0, 50)));

            // Save to global Dreamlo leaderboard (with streak in text field)
            try {
                const safeName = encodeURIComponent(name.replace(/[^a-zA-Z0-9]/g, '').substring(0, 12) || 'PLAYER');
                // Dreamlo format: /add/name/score/seconds/text - we use seconds for streak
                await fetch(`https://www.dreamlo.com/lb/${DREAMLO_PRIVATE}/add/${safeName}/${score}/${bestStreak}`);
                console.log('Score saved globally with streak!');
            } catch (err) {
                console.log('Error saving to global leaderboard:', err);
            }
        }

        async function displayLeaderboard(elementId) {
            const container = document.getElementById(elementId);
            if (!container) return;

            container.innerHTML = '<h3>GLOBAL LEADERBOARD</h3><p style="color:#888;font-size:10px;">Loading...</p>';

            await fetchLeaderboard();

            let html = '<h3>GLOBAL LEADERBOARD</h3>';
            html += '<div style="display:flex;justify-content:space-between;font-size:8px;color:#888;padding:2px 5px;border-bottom:1px solid #333;"><span>PLAYER</span><span>SCORE</span><span>STREAK</span></div>';
            const top10 = globalLeaderboard.slice(0, 10);
            if (top10.length === 0) {
                html += '<p style="color:#888;font-size:10px;">No scores yet! Be the first!</p>';
            } else {
                top10.forEach((entry, i) => {
                    let cls = '';
                    if (i === 0) cls = 'gold';
                    else if (i === 1) cls = 'silver';
                    else if (i === 2) cls = 'bronze';
                    const streakDisplay = entry.streak > 0 ? `üî•${entry.streak}` : '-';
                    html += `<div class="leaderboard-entry ${cls}" style="display:flex;justify-content:space-between;">
                        <span style="flex:1;">${i + 1}. ${entry.name}</span>
                        <span style="width:50px;text-align:right;">${entry.score}</span>
                        <span style="width:40px;text-align:right;">${streakDisplay}</span>
                    </div>`;
                });
            }
            container.innerHTML = html;
        }

        // GameMonetize Ads Integration
        const GAME_ID = '4kci7og3klgj0ivy2wz3gdvd9dth5e7n';
        let adCallback = null;
        let adsWatched = 0;
        let sdkReady = false;

        // Initialize GameMonetize SDK
        function initGameMonetizeSDK() {
            if (typeof GameMonetize !== 'undefined') {
                GameMonetize.init({
                    gameId: GAME_ID,
                    onEvent: function(event) {
                        console.log('GameMonetize event:', event.name);
                        if (event.name === 'SDK_READY') {
                            sdkReady = true;
                            console.log('GameMonetize SDK ready!');
                        } else if (event.name === 'AD_SUCCESS' || event.name === 'AD_COMPLETED') {
                            adsWatched++;
                            document.getElementById('adOverlay').classList.add('hidden');
                            if (adCallback) adCallback(true);
                        } else if (event.name === 'AD_FAILED' || event.name === 'AD_REJECTED' || event.name === 'AD_DISMISS') {
                            console.log('Ad not available or dismissed');
                            document.getElementById('adOverlay').classList.add('hidden');
                            if (adCallback) adCallback(true); // Continue anyway
                        }
                    }
                });
            } else if (typeof sdk !== 'undefined' && sdk.init) {
                // Alternative SDK pattern
                sdk.init(GAME_ID);
                sdkReady = true;
            } else {
                console.log('GameMonetize SDK not found - ads will be simulated');
            }
        }

        // Try to init SDK when page loads
        window.addEventListener('load', initGameMonetizeSDK);

        let adCountdownInterval = null;

        // Track which overlay was showing before ad
        let overlayBeforeAd = null;

        function showAd(onComplete, isRewarded = false) {
            adCallback = onComplete;
            gamePaused = true; // PAUSE THE GAME

            // Remember which overlay was showing and hide ALL overlays for the ad
            overlayBeforeAd = null;
            ['levelOverlay', 'gameOverOverlay', 'startOverlay'].forEach(id => {
                const el = document.getElementById(id);
                if (el && !el.classList.contains('hidden')) {
                    overlayBeforeAd = id;
                    el.classList.add('hidden');
                }
            });

            // Add class to body so CSS can force GameMonetize to top
            document.body.classList.add('ad-playing');

            // Show our ad overlay (but it will be hidden by CSS while ad plays)
            document.getElementById('adOverlay').classList.remove('hidden');
            document.getElementById('closeAdBtn').style.display = 'none';
            document.getElementById('adTitle').textContent = isRewarded ? 'EARNING EXTRA LIFE!' : 'LOADING...';
            document.getElementById('adStatus').textContent = 'Please wait...';

            // Start countdown from 5
            let countdown = 5;
            document.getElementById('adCountdown').textContent = countdown;

            // Clear any existing interval
            if (adCountdownInterval) clearInterval(adCountdownInterval);

            adCountdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    document.getElementById('adCountdown').textContent = countdown;
                } else {
                    document.getElementById('adCountdown').textContent = isRewarded ? '+1 LIFE!' : 'GO!';
                    document.getElementById('adStatus').textContent = 'Ready!';
                }
            }, 1000);

            // Try to show real ad
            let adShown = false;
            if (typeof GameMonetize !== 'undefined' && GameMonetize.showAd) {
                try {
                    GameMonetize.showAd();
                    adShown = true;
                    console.log('Showing ad via GameMonetize.showAd()');
                } catch(e) {
                    console.log('GameMonetize.showAd error:', e);
                }
            }
            if (!adShown && typeof sdk !== 'undefined') {
                try {
                    if (sdk.showBanner) { sdk.showBanner(); adShown = true; }
                    else if (sdk.showAd) { sdk.showAd(); adShown = true; }
                } catch(e) { console.log('SDK ad error:', e); }
            }

            // Complete after countdown (5 seconds) regardless of ad
            setTimeout(() => {
                clearInterval(adCountdownInterval);
                finishAd(true);
            }, 5000);

            // Show skip button after 3 seconds
            setTimeout(() => {
                const skipBtn = document.getElementById('closeAdBtn');
                if (skipBtn && !document.getElementById('adOverlay').classList.contains('hidden')) {
                    skipBtn.style.display = 'block';
                }
            }, 3000);
        }

        function finishAd(success, keepPaused = false) {
            if (adCountdownInterval) {
                clearInterval(adCountdownInterval);
                adCountdownInterval = null;
            }

            // Remove ad-playing class
            document.body.classList.remove('ad-playing');

            document.getElementById('adOverlay').classList.add('hidden');
            document.getElementById('closeAdBtn').style.display = 'none';

            // Only unpause if not told to keep paused
            if (!keepPaused) {
                gamePaused = false;
            }
            adsWatched++;

            // Restore the overlay that was showing before ad (if any)
            if (overlayBeforeAd) {
                document.getElementById(overlayBeforeAd).classList.remove('hidden');
                overlayBeforeAd = null;
            }

            if (adCallback) {
                adCallback(success);
                adCallback = null;
            }
        }

        // Close ad button handler
        document.getElementById('closeAdBtn')?.addEventListener('click', () => {
            finishAd(true);
        });

        function showRewardedAd(onReward) {
            showAd((success) => {
                if (success && onReward) onReward();
            }, true); // true = isRewarded
        }

        // Share functionality
        const GAME_URL = 'https://mosalahgame.com';

        function shareScore(platform) {
            const text = `I scored ${totalScore} points in Mo Salah Goal Machine! Can you beat me? üèÜ‚öΩ`;
            const url = GAME_URL;

            switch(platform) {
                case 'x':
                    window.open(`https://x.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`, '_blank');
                    break;
                case 'whatsapp':
                    window.open(`https://wa.me/?text=${encodeURIComponent(text + ' ' + url)}`, '_blank');
                    break;
                case 'facebook':
                    window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}&quote=${encodeURIComponent(text)}`, '_blank');
                    break;
                case 'copy':
                    navigator.clipboard.writeText(text + ' ' + url).then(() => {
                        alert('Link copied! Share it with friends!');
                    });
                    break;
            }
        }

        // Generate shareable score card image
        function generateScoreCard() {
            const cardCanvas = document.createElement('canvas');
            cardCanvas.width = 600;
            cardCanvas.height = 400;
            const cardCtx = cardCanvas.getContext('2d');

            // Background gradient
            const grad = cardCtx.createLinearGradient(0, 0, 600, 400);
            grad.addColorStop(0, '#1a1a2e');
            grad.addColorStop(1, '#c8102e');
            cardCtx.fillStyle = grad;
            cardCtx.fillRect(0, 0, 600, 400);

            // Add pitch pattern
            cardCtx.fillStyle = 'rgba(45, 90, 39, 0.3)';
            for (let i = 0; i < 10; i++) {
                if (i % 2 === 0) {
                    cardCtx.fillRect(0, 280 + i * 12, 600, 12);
                }
            }

            // Title
            cardCtx.fillStyle = '#ffd700';
            cardCtx.font = 'bold 28px "Press Start 2P", monospace';
            cardCtx.textAlign = 'center';
            cardCtx.fillText('MO SALAH', 300, 60);
            cardCtx.fillText('GOAL MACHINE', 300, 100);

            // Score box
            cardCtx.fillStyle = 'rgba(0,0,0,0.6)';
            cardCtx.fillRect(100, 130, 400, 150);
            cardCtx.strokeStyle = '#ffd700';
            cardCtx.lineWidth = 4;
            cardCtx.strokeRect(100, 130, 400, 150);

            // Score
            cardCtx.fillStyle = '#fff';
            cardCtx.font = '16px "Press Start 2P", monospace';
            cardCtx.fillText('FINAL SCORE', 300, 170);

            cardCtx.fillStyle = '#ffd700';
            cardCtx.font = 'bold 48px "Press Start 2P", monospace';
            cardCtx.fillText(totalScore.toString(), 300, 230);

            // Stats
            cardCtx.fillStyle = '#fff';
            cardCtx.font = '10px "Press Start 2P", monospace';
            cardCtx.fillText(`BEST STREAK: ${bestStreak}x`, 300, 265);

            // Player name
            const playerName = document.getElementById('playerName')?.value || 'PLAYER';
            cardCtx.fillStyle = '#c8102e';
            cardCtx.fillRect(175, 300, 250, 35);
            cardCtx.fillStyle = '#fff';
            cardCtx.font = '12px "Press Start 2P", monospace';
            cardCtx.fillText(playerName.toUpperCase(), 300, 323);

            // Footer
            cardCtx.fillStyle = 'rgba(255,255,255,0.7)';
            cardCtx.font = '8px "Press Start 2P", monospace';
            cardCtx.fillText('mosalahgame.com - Play Now!', 300, 380);

            // Download the image
            const link = document.createElement('a');
            link.download = `mosalah-score-${totalScore}.png`;
            link.href = cardCanvas.toDataURL('image/png');
            link.click();
        }

        // Tips system
        const tips = [
            "TIP: Hold SHOOT longer for more power, but careful - too much goes over!",
            "TIP: Move unpredictably to dodge defenders!",
            "TIP: Shoot when defenders are far away!",
            "TIP: In free kicks, aim high for top corner screamers!",
            "TIP: Medium power (yellow bar) is often best!",
            "TIP: Watch the keeper's position before shooting!",
            "TIP: You can earn extra lives by watching ads!",
            "TIP: Share your score to challenge friends!"
        ];
        let currentTip = 0;
        let tipTimer = 0;

        function getNextTip() {
            const tip = tips[currentTip];
            currentTip = (currentTip + 1) % tips.length;
            return tip;
        }

        // Intro scene state
        let introActive = true;
        let introFrame = 0;
        let introBallX = 100;
        let introBallY = 250;
        let introPhase = 'run'; // run, kick, goal, celebrate

        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ') {
                handleShootPress();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'r' && gameState === 'playing') {
                resetPositions();
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            if (e.key === ' ') handleShootRelease();
        });

        // Mobile controls
        const joystick = document.getElementById('joystick');
        const knob = document.getElementById('knob');
        const shootBtn = document.getElementById('shootBtn');
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let touchMove = { x: 0, y: 0 };

        joystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
            const rect = joystick.getBoundingClientRect();
            joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        });

        document.addEventListener('touchmove', (e) => {
            if (!joystickActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            const maxDist = 30;
            let dx = touch.clientX - joystickCenter.x;
            let dy = touch.clientY - joystickCenter.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
            knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            touchMove = { x: dx / maxDist, y: dy / maxDist };
        }, { passive: false });

        document.addEventListener('touchend', () => {
            if (joystickActive) {
                joystickActive = false;
                knob.style.transform = 'translate(-50%, -50%)';
                touchMove = { x: 0, y: 0 };
            }
        });

        shootBtn.addEventListener('touchstart', (e) => { e.preventDefault(); handleShootPress(); });
        shootBtn.addEventListener('touchend', (e) => { e.preventDefault(); handleShootRelease(); });

        function handleShootPress() {
            if (gameState === 'playing' && salah.hasBall && !shotCharging) {
                startCharging();
            } else if (gameState === 'freeKick' && freeKickPhase === 'aim' && !shotCharging) {
                // Lock target position and move to power phase
                shootFPVFreeKick();
            } else if (gameState === 'freeKick' && freeKickPhase === 'power' && !fkBallFlying) {
                // Already in power phase, continue charging
            }
        }

        function handleShootRelease() {
            if (shotCharging) {
                if (gameState === 'playing' && salah.hasBall) {
                    shootBall(shotPower);
                } else if (gameState === 'freeKick' && freeKickPhase === 'power') {
                    // Release the shot
                    shootFPVFreeKick();
                }
                if (gameState !== 'freeKick' || freeKickPhase !== 'power') {
                    shotCharging = false;
                    shotPower = 0;
                }
            }
        }

        function startCharging() {
            shotCharging = true;
            chargeStartTime = Date.now();
            shotPower = 0;
        }

        function shootBall(power) {
            gameState = 'shooting';
            salah.hasBall = false;
            salah.kickFrame = 10;

            // Detect worldie attempt (shooting from outside the box - x < 450)
            const distanceFromGoal = goal.x - salah.x;
            isWorldieAttempt = distanceFromGoal > 300; // About 300 pixels is "outside the box"
            worldieGoalScored = false;

            const powerPercent = power / maxShotPower;
            const basePower = 10 + powerPercent * 8;
            // EASIER: Reduced aim variance from 60 to 40
            let aimVariance = (Math.random() - 0.5) * 40;

            // Worldies are harder but have special properties
            if (isWorldieAttempt) {
                aimVariance *= 1.2; // Slightly less accurate (was 1.3)
                // Add curve for long range shots (dramatic effect)
                ball.curve = (Math.random() - 0.5) * 0.15;
            }

            let goingOver = false;
            // EASIER: Higher threshold before going over (was 0.75/0.65)
            const overThreshold = isWorldieAttempt ? 0.72 : 0.82;
            if (powerPercent > overThreshold && Math.random() < (powerPercent - 0.6) * 0.6) {
                goingOver = true;
            }

            ball.targetY = goingOver ? goal.y - 50 - Math.random() * 100 : goal.y + goal.height / 2 + aimVariance;
            ball.active = true;
            ball.velocityX = basePower;
            ball.velocityY = (ball.targetY - ball.y) / ((goal.x - ball.x) / basePower);
            if (!isWorldieAttempt) ball.curve = 0;

            const level = levels[currentLevel];
            // EASIER: Longer reaction delay for keeper (gives ball more time)
            const reactionDelay = isWorldieAttempt
                ? 100 + Math.random() * 120 + (powerPercent * 40)
                : 130 + Math.random() * 180 + (powerPercent * 60);

            setTimeout(() => {
                if (gameState === 'shooting') {
                    const predictedY = ball.y + ball.velocityY * ((alisson.x - ball.x) / ball.velocityX);
                    // EASIER: Keeper misjudges more - add random error
                    const keeperError = (Math.random() - 0.5) * 30;
                    const curveEffect = isWorldieAttempt ? ball.curve * 40 : 0;
                    alisson.targetY = predictedY + curveEffect + keeperError;
                    alisson.diving = true;
                    alisson.diveDirection = predictedY > alisson.y ? 1 : -1;
                }
            }, reactionDelay);
        }

        function shootFreeKick() {
            gameState = 'shooting';
            salah.kickFrame = 10;

            const power = shotPower || 60;
            const powerPercent = power / maxShotPower;
            const basePower = 8 + powerPercent * 6;

            // Bend affects curve - more bend = more curve but harder to control
            const bendPercent = (bendAmount - 50) / 50; // -1 to 1
            ball.curve = bendPercent * 0.3;

            // Target based on bend
            const targetY = goal.y + goal.height / 2 + bendPercent * 80;

            ball.active = true;
            ball.velocityX = basePower;
            ball.velocityY = (targetY - ball.y) / ((goal.x - ball.x) / basePower) - ball.curve * 5;

            // High bend = risk of missing
            if (Math.abs(bendPercent) > 0.7 && Math.random() < Math.abs(bendPercent) * 0.3) {
                ball.velocityY += (Math.random() - 0.5) * 4;
            }

            const level = levels[currentLevel];
            setTimeout(() => {
                if (gameState === 'shooting') {
                    const predictedY = ball.y + ball.velocityY * ((alisson.x - ball.x) / ball.velocityX);
                    alisson.targetY = predictedY + ball.curve * 50; // Keeper misjudges curve
                    alisson.diving = true;
                    alisson.diveDirection = predictedY > alisson.y ? 1 : -1;
                }
            }, 150);
        }

        function resetPositions() {
            const level = levels[currentLevel];

            if (level.freeKick) {
                salah.x = 400;
                salah.y = 350;
                ball.x = 420;
                ball.y = 365;
                gameState = 'freeKick';
                freeKickPhase = 'aim';
                setupWall(level.wallSize || 4);
                // Reset free kick state - new moving target system
                fkTargetX = 400;
                fkTargetDir = 1;
                fkBallPos = { x: 400, y: 430 };
                fkBallTarget = { x: 400, y: 150 };
                fkBallFlying = false;
                fkKeeperX = 400;
                fkKeeperDiving = false;
                fkKeeperTargetX = 400;
                fkPower = 0;
                fkResult = null;
                document.getElementById('message').textContent = 'TAP to lock target, then HOLD for power!';
            } else {
                salah.x = 200;
                salah.y = 250;
                ball.x = 220;
                ball.y = 270;
                gameState = 'playing';
                document.getElementById('message').textContent = 'Hold SHOOT to power up!';
            }

            salah.hasBall = true;
            salah.kickFrame = 0;
            salah.celebrating = false;
            salah.celebrateFrame = 0;
            ball.active = false;
            ball.velocityX = 0;
            ball.velocityY = 0;
            ball.curve = 0;
            alisson.x = 700;
            alisson.y = 250;
            alisson.diving = false;
            alisson.diveFrame = 0;
            shotCharging = false;
            shotPower = 0;

            // Reset worldie and replay state
            isWorldieAttempt = false;
            worldieGoalScored = false;
            replayBuffer = [];
            isRecording = true;

            // Reset defenders - positioned further back, especially for 3-defender level
            const defSpeed = level.defenderSpeed || 2.0;
            const isThreeDefenders = level.defenders?.length === 3;
            const defXOffset = isThreeDefenders ? 60 : 0; // Push back further on 3-defender level

            defenders.konate.x = 520 + defXOffset; defenders.konate.y = 250; defenders.konate.speed = defSpeed;
            defenders.vandijk.x = 480 + defXOffset; defenders.vandijk.y = 180; defenders.vandijk.speed = defSpeed * 0.9;
            defenders.robertson.x = 500 + defXOffset; defenders.robertson.y = 320; defenders.robertson.speed = defSpeed * 1.1;
            defenders.bradley.x = 450; defenders.bradley.y = 250; defenders.bradley.speed = defSpeed * 1.05;
        }

        function setupWall(size) {
            wallPlayers = [];
            const startY = goal.y + goal.height / 2 - (size * 25) / 2;
            for (let i = 0; i < size; i++) {
                wallPlayers.push({ x: 550, y: startY + i * 25, width: 20, height: 45 });
            }
        }

        function startLevel(levelIndex) {
            currentLevel = levelIndex;
            levelGoals = 0;
            const level = levels[currentLevel];
            document.getElementById('level').textContent = level.suddenDeath ? 'SD' : (currentLevel + 1);
            document.getElementById('totalLevels').textContent = levels.length;
            document.getElementById('target').textContent = level.suddenDeath ? '‚àû' : level.target;
            document.getElementById('goals').textContent = '0';
            resetPositions();
            document.getElementById('levelOverlay').classList.add('hidden');

            // Show sudden death announcement
            if (level.suddenDeath) {
                document.getElementById('message').textContent = 'SUDDEN DEATH! Score until you drop!';
            }
        }

        function completeLevel() {
            const level = levels[currentLevel];
            const bonus = level.freeKick ? 50 : level.target * 10;
            totalScore += bonus;
            document.getElementById('totalScore').textContent = totalScore;

            if (currentLevel < levels.length - 1) {
                const nextLevel = levels[currentLevel + 1];
                if (nextLevel.suddenDeath) {
                    document.getElementById('levelTitle').textContent = 'FINAL LEVEL!';
                    document.getElementById('levelScore').textContent = `+${bonus} points! Total: ${totalScore}`;
                    document.getElementById('levelDesc').textContent = 'SUDDEN DEATH: Endless mode! Score as many as you can before losing all lives. Your final score = LIMITLESS!';
                } else {
                    document.getElementById('levelTitle').textContent = 'LEVEL COMPLETE!';
                    document.getElementById('levelScore').textContent = `+${bonus} points!`;
                    document.getElementById('levelDesc').textContent = nextLevel.desc;
                }
                document.getElementById('levelOverlay').classList.remove('hidden');
                gameState = 'levelComplete';
            } else {
                // This shouldn't happen in Sudden Death but just in case
                endGame(true);
            }
        }

        async function endGame(completed) {
            // Don't trigger game over if ad is playing
            if (document.body.classList.contains('ad-playing')) {
                console.log('Prevented game over during ad');
                return;
            }

            gameState = 'gameOver';
            screenShake = 0; // Stop any screen shake
            document.getElementById('finalScore').textContent = totalScore;

            // Show best streak
            if (bestStreak >= 3) {
                document.getElementById('bestStreakDisplay').textContent = `üî• Best Streak: ${bestStreak} in a row!`;
            } else {
                document.getElementById('bestStreakDisplay').textContent = '';
            }

            const level = levels[currentLevel];
            let msg;
            if (level && level.suddenDeath) {
                msg = `SUDDEN DEATH: ${levelGoals} goals scored!`;
            } else if (completed) {
                msg = 'INCREDIBLE! You completed all levels!';
            } else {
                msg = `You reached Level ${currentLevel + 1}`;
            }
            document.getElementById('gameOverMsg').textContent = msg;
            document.getElementById('gameOverOverlay').classList.remove('hidden');

            // Save score and refresh leaderboard
            await saveScore(playerName, totalScore);
            await displayLeaderboard('gameOverLeaderboard');
        }

        function handleGoal(isPostGoal = false) {
            levelGoals++;
            const level = levels[currentLevel];

            // Combo system - consecutive goals!
            currentStreak++;
            if (currentStreak > bestStreak) bestStreak = currentStreak;

            // Calculate combo multiplier (max 5x)
            comboMultiplier = Math.min(5, 1 + Math.floor(currentStreak / 2));

            // Check for worldie goal (long-range screamer)
            const isWorldie = isWorldieAttempt && !level.freeKick;
            if (isWorldie) worldieGoalScored = true;

            // Base points with combo multiplier - worldies get 2x bonus!
            const basePoints = level.suddenDeath ? 15 : (isWorldie ? 20 : 10);
            const goalPoints = basePoints * comboMultiplier;
            totalScore += goalPoints;

            document.getElementById('goals').textContent = levelGoals;
            document.getElementById('totalScore').textContent = totalScore;

            const isFreeKick = level.freeKick;
            const isSuddenDeath = level.suddenDeath;

            // Dynamic message based on streak and worldie
            let message = '';
            if (isWorldie) {
                // Worldie gets special treatment!
                message = `üöÄ ${randomMessage(worldieMessages)} +${goalPoints}pts`;
                if (comboMultiplier > 1) message += ` (${comboMultiplier}x)`;
            } else if (isPostGoal) {
                message = `üéØ OFF THE POST AND IN! +${goalPoints}pts`;
                if (comboMultiplier > 1) message += ` (${comboMultiplier}x)`;
            } else if (currentStreak >= 5) {
                message = `üî• ON FIRE! ${currentStreak} IN A ROW! +${goalPoints}pts (${comboMultiplier}x)`;
            } else if (currentStreak >= 3) {
                message = `‚ö° STREAK x${currentStreak}! +${goalPoints}pts (${comboMultiplier}x)`;
            } else if (comboMultiplier > 1) {
                message = `GOAL! +${goalPoints}pts (${comboMultiplier}x COMBO!)`;
            } else if (isSuddenDeath) {
                message = `GOAL #${levelGoals}! +${goalPoints} pts! Keep going!`;
            } else {
                message = isFreeKick ? randomMessage(freeKickMessages) : randomMessage(goalMessages);
            }

            // Define celebration function
            const runCelebration = () => {
                document.getElementById('message').textContent = message;

                // Screen shake on goal! Worldies shake more!
                screenShake = isWorldie ? 20 : (isPostGoal ? 15 : 10);
                lastGoalTime = Date.now();

                gameState = 'celebrating';
                salah.celebrating = true;
                salah.celebrateFrame = 0;

                setTimeout(() => {
                    // In Sudden Death, never complete - just keep playing
                    if (isSuddenDeath) {
                        resetPositions();
                    } else if (levelGoals >= level.target) {
                        completeLevel();
                    } else {
                        resetPositions();
                    }
                }, 2000);
            };

            // Trigger instant replay for spectacular goals (worldies and post goals)
            if ((isWorldie || isPostGoal) && !isFreeKick && replayBuffer.length >= 20) {
                pendingCelebration = runCelebration;
                const replayStarted = startReplay(isWorldie ? 'worldie' : 'post_in');
                if (!replayStarted) {
                    // Replay failed to start, just celebrate normally
                    pendingCelebration = null;
                    runCelebration();
                }
            } else {
                // Normal goal - just celebrate
                runCelebration();
            }
        }

        function handleMiss(isSave) {
            lives--;
            deathCount++;

            // Reset streak on miss
            if (currentStreak >= 3) {
                document.getElementById('message').textContent = `Streak ended at ${currentStreak}! ${isSave ? randomMessage(saveMessages) : randomMessage(missMessages)}`;
            } else {
                document.getElementById('message').textContent = isSave
                    ? randomMessage(saveMessages)
                    : randomMessage(missMessages);
            }
            currentStreak = 0;
            comboMultiplier = 1;
            gameState = 'saved';

            if (lives <= 0) {
                setTimeout(() => endGame(false), 1500);
            } else {
                // Show ad every 3rd death (not too annoying)
                if (deathCount % 3 === 0) {
                    setTimeout(() => {
                        showAd(() => {
                            // Reset positions FIRST, then pause
                            resetPositions();
                            setTimeout(() => {
                                gamePaused = true;
                                document.getElementById('pauseBtn').textContent = '‚ñ∂';
                                document.getElementById('message').textContent = 'Tap anywhere to play!';
                            }, 50);
                        });
                    }, 1500);
                } else {
                    setTimeout(resetPositions, 1500);
                }
            }
        }

        function handleTackle(defenderName) {
            lives--;
            deathCount++;
            currentStreak = 0;
            comboMultiplier = 1;

            const name = defenderName.charAt(0).toUpperCase() + defenderName.slice(1).replace('-', ' ');
            document.getElementById('message').textContent = `${name}: ${randomMessage(tackleMessages)}`;
            gameState = 'tackled';

            if (lives <= 0) {
                setTimeout(() => endGame(false), 1500);
            } else {
                // Show ad every 3rd death
                if (deathCount % 3 === 0) {
                    setTimeout(() => {
                        showAd(() => {
                            // Reset positions FIRST, then pause
                            resetPositions();
                            setTimeout(() => {
                                gamePaused = true;
                                document.getElementById('pauseBtn').textContent = '‚ñ∂';
                                document.getElementById('message').textContent = 'Tap anywhere to play!';
                            }, 50);
                        });
                    }, 1500);
                } else {
                    setTimeout(resetPositions, 1500);
                }
            }
        }

        // Drawing functions
        function drawField() {
            ctx.fillStyle = '#2d5a27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#347a2c';
            for (let i = 0; i < canvas.width; i += 60) ctx.fillRect(i, 0, 30, canvas.height);

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.strokeRect(600, 100, 200, 300);
            ctx.strokeRect(700, 175, 100, 150);

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(650, 250, 4, 0, Math.PI * 2);
            ctx.fill();

            // Free kick spot
            if (levels[currentLevel]?.freeKick) {
                ctx.beginPath();
                ctx.arc(420, 365, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Goal - Face-on style with 3D depth effect
            const goalDepth = 45; // How far back the net goes

            // Dark interior (back of goal)
            ctx.fillStyle = '#1a3d1a';
            ctx.fillRect(goal.x, goal.y + goal.postWidth, goalDepth, goal.height - goal.postWidth * 2);

            // Net - back panel (darker, smaller squares)
            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = 1;
            for (let i = goal.y + goal.postWidth; i < goal.y + goal.height - goal.postWidth; i += 12) {
                ctx.beginPath();
                ctx.moveTo(goal.x + 5, i);
                ctx.lineTo(goal.x + goalDepth - 5, i);
                ctx.stroke();
            }
            for (let i = goal.x + 5; i < goal.x + goalDepth - 5; i += 12) {
                ctx.beginPath();
                ctx.moveTo(i, goal.y + goal.postWidth);
                ctx.lineTo(i, goal.y + goal.height - goal.postWidth);
                ctx.stroke();
            }

            // Net - side panels (perspective lines going back)
            ctx.strokeStyle = 'rgba(255,255,255,0.35)';
            // Top net panel
            for (let i = 0; i <= goalDepth; i += 10) {
                ctx.beginPath();
                ctx.moveTo(goal.x + goalDepth, goal.y + goal.postWidth);
                ctx.lineTo(goal.x + i, goal.y + goal.postWidth + (goalDepth - i) * 0.3);
                ctx.stroke();
            }
            // Bottom net panel
            for (let i = 0; i <= goalDepth; i += 10) {
                ctx.beginPath();
                ctx.moveTo(goal.x + goalDepth, goal.y + goal.height - goal.postWidth);
                ctx.lineTo(goal.x + i, goal.y + goal.height - goal.postWidth - (goalDepth - i) * 0.3);
                ctx.stroke();
            }

            // Goal frame - white posts (front-facing)
            ctx.fillStyle = '#fff';
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            // Front post (left side of goal opening)
            ctx.fillRect(goal.x + goalDepth - 4, goal.y, 10, goal.height);

            // Crossbar (top)
            ctx.fillRect(goal.x, goal.y, goalDepth + 6, 10);

            // Bottom bar
            ctx.fillRect(goal.x, goal.y + goal.height - 10, goalDepth + 6, 10);

            // Back post
            ctx.fillStyle = '#ddd';
            ctx.fillRect(goal.x, goal.y, 6, goal.height);

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;

            // Lives indicator
            ctx.fillStyle = '#c8102e';
            for (let i = 0; i < lives; i++) {
                ctx.beginPath();
                ctx.arc(30 + i * 25, 25, 8, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawSalah(x, y) {
            const skinColor = '#c68642';
            const hairColor = '#1a1a1a';
            const shirtColor = '#c8102e';

            // Curly hair
            ctx.fillStyle = hairColor;
            ctx.fillRect(x + 4, y - 4, 24, 12);
            ctx.fillRect(x, y, 8, 8);
            ctx.fillRect(x + 24, y, 8, 8);
            ctx.fillRect(x + 2, y + 6, 6, 8);
            ctx.fillRect(x + 24, y + 6, 6, 8);

            // Head
            ctx.fillStyle = skinColor;
            ctx.fillRect(x + 6, y + 4, 20, 18);

            // Eyes
            ctx.fillStyle = '#000';
            ctx.fillRect(x + 10, y + 10, 4, 4);
            ctx.fillRect(x + 18, y + 10, 4, 4);

            // Beard
            ctx.fillStyle = hairColor;
            ctx.fillRect(x + 6, y + 16, 20, 6);
            ctx.fillRect(x + 10, y + 14, 12, 4);

            // Body
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + 4, y + 22, 24, 18);

            // Number 11
            ctx.fillStyle = '#fff';
            ctx.fillRect(x + 10, y + 26, 3, 10);
            ctx.fillRect(x + 18, y + 26, 3, 10);

            // Arms
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x - 2, y + 22, 8, 14);
            ctx.fillRect(x + 26, y + 22, 8, 14);

            // Hands
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 2, y + 34, 6, 6);
            ctx.fillRect(x + 28, y + 34, 6, 6);

            // Shorts & legs
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + 6, y + 40, 20, 10);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x + 8, y + 50, 6, 10);
            ctx.fillRect(x + 18, y + 50, 6, 10);

            // Boots
            ctx.fillStyle = '#f97316';
            ctx.fillRect(x + 6, y + 58, 10, 6);
            ctx.fillRect(x + 16, y + 58, 10, 6);

            // Kick animation
            if (salah.kickFrame > 0) {
                ctx.fillStyle = skinColor;
                ctx.fillRect(x + 24, y + 48, 12, 6);
                ctx.fillStyle = '#f97316';
                ctx.fillRect(x + 32, y + 48, 10, 6);
            }

            // Celebration
            if (salah.celebrating) {
                const jump = Math.sin(salah.celebrateFrame * 0.3) * 10;
                const wave = Math.sin(salah.celebrateFrame * 0.5) * 8;
                ctx.fillStyle = shirtColor;
                ctx.fillRect(x - 6, y + 10 - jump + wave, 10, 16);
                ctx.fillRect(x + 28, y + 10 - jump - wave, 10, 16);
                ctx.fillStyle = skinColor;
                ctx.fillRect(x - 6, y + 4 - jump + wave, 8, 8);
                ctx.fillRect(x + 30, y + 4 - jump - wave, 8, 8);
            }
        }

        function drawAlisson(x, y, diving, diveDir) {
            const skinColor = '#d4a574';
            const hairColor = '#4a3728';
            const shirtColor = '#32CD32';
            const shortsColor = '#228B22';
            const glovesColor = '#FFD700';

            if (diving) {
                const offset = Math.min(alisson.diveFrame * 3, 40) * diveDir;
                y += offset;
                ctx.fillStyle = shirtColor;
                ctx.fillRect(x - 8, y + 16, 40, 16);
                ctx.fillRect(x - 16, y + 8, 16, 12);
                ctx.fillRect(x + 32, y + 8, 16, 12);
                ctx.fillStyle = glovesColor;
                ctx.fillRect(x - 24, y + 8, 12, 16);
                ctx.fillRect(x + 44, y + 8, 12, 16);
                ctx.fillStyle = skinColor;
                ctx.fillRect(x + 8, y, 20, 20);
                ctx.fillStyle = hairColor;
                ctx.fillRect(x + 8, y, 20, 8);
                ctx.fillStyle = shortsColor;
                ctx.fillRect(x, y + 32, 32, 8);
            } else {
                ctx.fillStyle = skinColor;
                ctx.fillRect(x + 8, y, 20, 20);
                ctx.fillStyle = hairColor;
                ctx.fillRect(x + 8, y, 20, 8);
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 12, y + 10, 4, 4);
                ctx.fillRect(x + 20, y + 10, 4, 4);
                ctx.fillStyle = shirtColor;
                ctx.fillRect(x + 4, y + 20, 28, 20);
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 16, y + 24, 4, 12);
                ctx.fillStyle = shirtColor;
                ctx.fillRect(x - 4, y + 20, 8, 16);
                ctx.fillRect(x + 32, y + 20, 8, 16);
                ctx.fillStyle = glovesColor;
                ctx.fillRect(x - 4, y + 32, 10, 10);
                ctx.fillRect(x + 30, y + 32, 10, 10);
                ctx.fillStyle = shortsColor;
                ctx.fillRect(x + 6, y + 40, 24, 10);
                ctx.fillStyle = skinColor;
                ctx.fillRect(x + 8, y + 50, 8, 12);
                ctx.fillRect(x + 20, y + 50, 8, 12);
                ctx.fillStyle = '#111';
                ctx.fillRect(x + 6, y + 60, 12, 6);
                ctx.fillRect(x + 18, y + 60, 12, 6);
            }
        }

        function drawDefender(x, y, number, skinColor) {
            const hairColor = '#1a1a1a';
            const shirtColor = '#c8102e';

            ctx.fillStyle = hairColor;
            ctx.fillRect(x + 6, y - 2, 20, 6);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x + 6, y + 2, 20, 20);
            ctx.fillStyle = '#fff';
            ctx.fillRect(x + 10, y + 10, 5, 4);
            ctx.fillRect(x + 17, y + 10, 5, 4);
            ctx.fillStyle = '#000';
            ctx.fillRect(x + 12, y + 11, 2, 2);
            ctx.fillRect(x + 19, y + 11, 2, 2);
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + 2, y + 22, 28, 22);

            // Number
            ctx.fillStyle = '#fff';
            ctx.font = '10px monospace';
            ctx.fillText(number.toString(), x + 10, y + 38);

            ctx.fillStyle = shirtColor;
            ctx.fillRect(x - 4, y + 22, 8, 16);
            ctx.fillRect(x + 28, y + 22, 8, 16);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 4, y + 36, 6, 6);
            ctx.fillRect(x + 30, y + 36, 6, 6);
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + 4, y + 44, 24, 12);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x + 6, y + 56, 8, 14);
            ctx.fillRect(x + 18, y + 56, 8, 14);
            ctx.fillStyle = '#111';
            ctx.fillRect(x + 4, y + 68, 12, 6);
            ctx.fillRect(x + 16, y + 68, 12, 6);
        }

        function drawWall() {
            wallPlayers.forEach(p => {
                ctx.fillStyle = '#c8102e';
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(p.x + 4, p.y, 12, 12);
            });
        }

        function drawBall() {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(ball.x + 2, ball.y + ball.radius + 4, ball.radius, ball.radius / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(ball.x - 2, ball.y - 2, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPowerMeter() {
            if (shotCharging) {
                const meterWidth = 100;
                const meterHeight = 12;
                const x = salah.x - 20;
                const y = salah.y - 30;
                const fillWidth = (shotPower / maxShotPower) * meterWidth;

                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(x - 2, y - 2, meterWidth + 4, meterHeight + 4);

                const powerPercent = shotPower / maxShotPower;
                ctx.fillStyle = powerPercent < 0.5 ? '#4ade80' : powerPercent < 0.75 ? '#fbbf24' : '#ef4444';
                ctx.fillRect(x, y, fillWidth, meterHeight);

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, meterWidth, meterHeight);

                ctx.fillStyle = '#fff';
                ctx.font = '8px monospace';
                ctx.fillText('POWER', x + 30, y - 5);
            }
        }

        function drawBendMeter() {
            if (gameState === 'bendSelect') {
                const meterWidth = 200;
                const meterHeight = 20;
                const x = canvas.width / 2 - meterWidth / 2;
                const y = 50;

                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(x - 5, y - 25, meterWidth + 10, meterHeight + 35);

                // Gradient for bend
                const gradient = ctx.createLinearGradient(x, 0, x + meterWidth, 0);
                gradient.addColorStop(0, '#3b82f6');
                gradient.addColorStop(0.5, '#4ade80');
                gradient.addColorStop(1, '#f59e0b');
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, meterWidth, meterHeight);

                // Indicator
                const indicatorX = x + (bendAmount / 100) * meterWidth;
                ctx.fillStyle = '#fff';
                ctx.fillRect(indicatorX - 3, y - 5, 6, meterHeight + 10);

                ctx.fillStyle = '#fff';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('LEFT          STRAIGHT          RIGHT', x + meterWidth / 2, y - 10);
                ctx.fillText('TAP SHOOT TO CONFIRM', x + meterWidth / 2, y + meterHeight + 15);
                ctx.textAlign = 'left';
            }
        }

        // ========== FREE KICK SYSTEM - FACE-ON VIEW ==========
        function drawFPVFreeKick() {
            // Goal dimensions (face-on, rectangular)
            const goalLeft = 200;
            const goalRight = 600;
            const goalTop = 100;
            const goalBottom = 280;
            const goalWidth = goalRight - goalLeft;
            const goalHeight = goalBottom - goalTop;

            // Sky/stadium background
            const skyGrad = ctx.createLinearGradient(0, 0, 0, 300);
            skyGrad.addColorStop(0, '#0a1628');
            skyGrad.addColorStop(1, '#1a3a5c');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, canvas.width, 300);

            // Stadium crowd (silhouette)
            ctx.fillStyle = '#0d2137';
            for (let i = 0; i < 40; i++) {
                const x = i * 20;
                const h = 30 + Math.sin(i * 0.5) * 15;
                ctx.fillRect(x, 50, 18, h);
            }

            // Floodlights
            ctx.fillStyle = 'rgba(255,255,200,0.3)';
            ctx.beginPath();
            ctx.arc(100, 30, 40, 0, Math.PI * 2);
            ctx.arc(700, 30, 40, 0, Math.PI * 2);
            ctx.fill();

            // Pitch
            ctx.fillStyle = '#2d5a27';
            ctx.fillRect(0, 280, canvas.width, 220);

            // Pitch stripes
            ctx.fillStyle = '#347a2c';
            for (let i = 0; i < 6; i++) {
                if (i % 2 === 0) ctx.fillRect(0, 280 + i * 35, canvas.width, 35);
            }

            // Goal net (face-on grid)
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 1;
            // Horizontal lines
            for (let i = 0; i <= 8; i++) {
                const y = goalTop + (goalHeight / 8) * i;
                ctx.beginPath();
                ctx.moveTo(goalLeft, y);
                ctx.lineTo(goalRight, y);
                ctx.stroke();
            }
            // Vertical lines
            for (let i = 0; i <= 12; i++) {
                const x = goalLeft + (goalWidth / 12) * i;
                ctx.beginPath();
                ctx.moveTo(x, goalTop);
                ctx.lineTo(x, goalBottom);
                ctx.stroke();
            }

            // Goal frame (white posts and crossbar)
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 12;
            // Left post
            ctx.beginPath();
            ctx.moveTo(goalLeft, goalTop);
            ctx.lineTo(goalLeft, goalBottom);
            ctx.stroke();
            // Right post
            ctx.beginPath();
            ctx.moveTo(goalRight, goalTop);
            ctx.lineTo(goalRight, goalBottom);
            ctx.stroke();
            // Crossbar
            ctx.beginPath();
            ctx.moveTo(goalLeft - 6, goalTop);
            ctx.lineTo(goalRight + 6, goalTop);
            ctx.stroke();

            // Keeper (Alisson)
            const keeperY = 200;
            const keeperWidth = 50;
            const keeperHeight = 70;

            if (fkKeeperDiving) {
                // Diving keeper - stretched out
                const diveOffset = (fkKeeperX - 400) * 0.5;
                ctx.fillStyle = '#32CD32'; // Green kit
                ctx.fillRect(fkKeeperX - 35 + diveOffset, keeperY + 20, 70, 25); // Body horizontal
                ctx.fillStyle = '#d4a574'; // Skin
                ctx.fillRect(fkKeeperX - 45 + diveOffset, keeperY + 15, 20, 20); // Head
                ctx.fillStyle = '#FFD700'; // Gloves
                ctx.fillRect(fkKeeperX + 30 + diveOffset, keeperY + 25, 20, 15); // Reaching hand
            } else {
                // Standing keeper
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(fkKeeperX - keeperWidth/2, keeperY, keeperWidth, keeperHeight);
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(fkKeeperX - 12, keeperY - 20, 24, 24); // Head
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(fkKeeperX - 35, keeperY + 15, 15, 20); // Left glove
                ctx.fillRect(fkKeeperX + 20, keeperY + 15, 15, 20); // Right glove
            }

            // Wall of defenders
            const level = levels[currentLevel];
            const wallSize = level?.wallSize || 3;
            const wallY = 320;
            const wallSpacing = 50;
            const wallStartX = 400 - ((wallSize - 1) * wallSpacing) / 2;

            for (let i = 0; i < wallSize; i++) {
                const wx = wallStartX + i * wallSpacing;
                // Body
                ctx.fillStyle = '#c8102e';
                ctx.fillRect(wx - 15, wallY, 30, 40);
                // Head
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(wx - 10, wallY - 15, 20, 18);
                // Hair
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(wx - 10, wallY - 15, 20, 6);
                // Hands protecting
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(wx - 8, wallY + 25, 16, 10);
            }

            // Moving target indicator (during aim phase)
            if (freeKickPhase === 'aim' && !fkBallFlying) {
                // Target reticle
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(fkTargetX, 180, 25, 0, Math.PI * 2);
                ctx.stroke();
                // Crosshair
                ctx.beginPath();
                ctx.moveTo(fkTargetX - 35, 180);
                ctx.lineTo(fkTargetX - 15, 180);
                ctx.moveTo(fkTargetX + 15, 180);
                ctx.lineTo(fkTargetX + 35, 180);
                ctx.moveTo(fkTargetX, 180 - 35);
                ctx.lineTo(fkTargetX, 180 - 15);
                ctx.moveTo(fkTargetX, 180 + 15);
                ctx.lineTo(fkTargetX, 180 + 35);
                ctx.stroke();

                // Instructions
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 18px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('TAP or HOLD SHOOT to lock target!', 400, 60);
                ctx.font = '12px monospace';
                ctx.fillStyle = '#fff';
                ctx.fillText('Target moves - time it right!', 400, 80);
            }

            // Locked target indicator (during power/flying phases)
            if ((freeKickPhase === 'power' || freeKickPhase === 'flying') && !fkResult) {
                ctx.strokeStyle = '#4ade80';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(fkBallTarget.x, 180, 20, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Power meter (when charging)
            if (freeKickPhase === 'power') {
                const pw = 300;
                const ph = 30;
                const px = 250;
                const py = 420;
                const powerPct = shotPower / maxShotPower;
                const fill = powerPct * pw;

                // Background
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(px - 15, py - 40, pw + 30, ph + 70);

                // Power zones visualization
                ctx.fillStyle = '#ef4444'; // Red - too weak (hits wall)
                ctx.fillRect(px, py, pw * 0.2, ph);
                ctx.fillStyle = '#4ade80'; // Green - good zone
                ctx.fillRect(px + pw * 0.2, py, pw * 0.5, ph);
                ctx.fillStyle = '#ef4444'; // Red - too strong (over)
                ctx.fillRect(px + pw * 0.7, py, pw * 0.3, ph);

                // Sweet spot marker at 50%
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(px + pw * 0.48, py - 5, 4, ph + 10);

                // Current power indicator
                ctx.fillStyle = '#fff';
                ctx.fillRect(px + fill - 3, py - 8, 6, ph + 16);

                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(px, py, pw, ph);

                // Labels
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('POWER - Release to shoot!', 400, py - 20);
                ctx.font = '10px monospace';
                ctx.fillText('WALL', px + pw * 0.1, py + ph + 15);
                ctx.fillText('PERFECT', px + pw * 0.45, py + ph + 15);
                ctx.fillText('OVER', px + pw * 0.85, py + ph + 15);

                // Locked target shown
                ctx.fillStyle = '#4ade80';
                ctx.font = '12px monospace';
                ctx.fillText('Target locked at X: ' + Math.round(fkBallTarget.x), 400, py + ph + 35);
            }

            // Ball
            if (fkBallFlying) {
                // Ball in flight
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(fkBallPos.x, fkBallPos.y, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(fkBallPos.x - 3, fkBallPos.y - 3, 4, 0, Math.PI * 2);
                ctx.fill();
            } else if (freeKickPhase !== 'done') {
                // Ball at feet
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(400, 430, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(397, 427, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Result message
            if (freeKickPhase === 'done' && fkResult) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(200, 180, 400, 80);
                ctx.font = 'bold 28px monospace';
                ctx.textAlign = 'center';
                if (fkResult === 'goal') {
                    ctx.fillStyle = '#4ade80';
                    ctx.fillText('GOAL!!!', 400, 230);
                } else if (fkResult === 'save') {
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillText('SAVED!', 400, 230);
                } else if (fkResult === 'over') {
                    ctx.fillStyle = '#ef4444';
                    ctx.fillText('OVER THE BAR!', 400, 230);
                } else if (fkResult === 'post') {
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillText('OFF THE POST!', 400, 230);
                } else if (fkResult === 'wall') {
                    ctx.fillStyle = '#ef4444';
                    ctx.fillText('BLOCKED BY WALL!', 400, 230);
                } else {
                    ctx.fillStyle = '#ef4444';
                    ctx.fillText('WIDE!', 400, 230);
                }
            }

            ctx.textAlign = 'left';
        }

        function updateFPVFreeKick() {
            const goalLeft = 200;
            const goalRight = 600;

            // Phase: AIM - target moves back and forth
            if (freeKickPhase === 'aim' && !fkBallFlying) {
                fkTargetX += fkTargetDir * fkTargetSpeed;
                // Bounce off goal posts
                if (fkTargetX <= goalLeft + 30) {
                    fkTargetX = goalLeft + 30;
                    fkTargetDir = 1;
                }
                if (fkTargetX >= goalRight - 30) {
                    fkTargetX = goalRight - 30;
                    fkTargetDir = -1;
                }
            }

            // Phase: POWER - charging shot
            if (freeKickPhase === 'power') {
                // Power is updated in main updateGame
            }

            // Phase: FLYING - ball moving towards goal
            if (freeKickPhase === 'flying' || fkBallFlying) {
                // Move ball towards target
                const dx = fkBallTarget.x - fkBallPos.x;
                const dy = fkBallTarget.y - fkBallPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 10) {
                    fkBallPos.x += dx * 0.08;
                    fkBallPos.y += dy * 0.08;

                    // Keeper reacts and dives
                    if (!fkKeeperDiving && fkBallPos.y < 350) {
                        fkKeeperDiving = true;
                        fkKeeperTargetX = fkBallTarget.x;
                    }

                    // Move keeper towards ball
                    if (fkKeeperDiving) {
                        const keeperDx = fkKeeperTargetX - fkKeeperX;
                        fkKeeperX += keeperDx * 0.12;
                        // Clamp keeper to goal
                        fkKeeperX = Math.max(goalLeft + 30, Math.min(goalRight - 30, fkKeeperX));
                    }
                } else {
                    // Ball reached target area - determine result
                    fkBallFlying = false;
                    freeKickPhase = 'done';

                    const powerPct = fkPower / maxShotPower;
                    const targetX = fkBallTarget.x;

                    // Power-based outcomes
                    if (powerPct < 0.20) {
                        // Too weak - hits wall
                        fkResult = 'wall';
                        document.getElementById('message').textContent = 'BLOCKED BY THE WALL!';
                        handleMiss(false);
                    } else if (powerPct > 0.70) {
                        // Too strong - goes over
                        fkResult = 'over';
                        document.getElementById('message').textContent = 'OVER THE BAR!';
                        handleMiss(false);
                    } else {
                        // Good power range (20-70%) - check if keeper saves
                        const keeperDist = Math.abs(targetX - fkKeeperX);

                        // Calculate score chance based on power (50% is optimal)
                        const optimalPower = 0.50;
                        const powerDiff = Math.abs(powerPct - optimalPower);
                        const baseChance = 0.70; // 70% base chance in good zone
                        const bonusChance = (0.25 - powerDiff) * 0.4; // Up to 10% bonus at 50%
                        const scoreChance = baseChance + Math.max(0, bonusChance);

                        // Post chance (rare)
                        const nearPost = targetX < goalLeft + 50 || targetX > goalRight - 50;
                        if (nearPost && Math.random() < 0.15) {
                            if (Math.random() < 0.3) {
                                // Off post and IN!
                                fkResult = 'goal';
                                document.getElementById('message').textContent = 'OFF THE POST AND IN!!!';
                                handleGoal();
                            } else {
                                fkResult = 'post';
                                document.getElementById('message').textContent = 'OFF THE POST!';
                                handleMiss(false);
                            }
                            return;
                        }

                        // Keeper save check - keeper must be close
                        if (keeperDist < 45) {
                            // Keeper is there - might save
                            if (Math.random() > scoreChance * 0.5) {
                                fkResult = 'save';
                                fkKeeperX = targetX; // Keeper reaches the ball
                                document.getElementById('message').textContent = randomMessage(saveMessages);
                                handleMiss(true);
                                return;
                            }
                        }

                        // GOAL!
                        if (Math.random() < scoreChance) {
                            fkResult = 'goal';
                            document.getElementById('message').textContent = randomMessage(freeKickMessages);
                            handleGoal();
                        } else {
                            // Unlucky miss
                            fkResult = Math.random() < 0.5 ? 'wide' : 'save';
                            document.getElementById('message').textContent = fkResult === 'save' ? randomMessage(saveMessages) : 'WIDE!';
                            handleMiss(fkResult === 'save');
                        }
                    }
                }
            }
        }

        function shootFPVFreeKick() {
            if (freeKickPhase === 'aim') {
                // Lock target and start power phase
                fkBallTarget.x = fkTargetX;
                freeKickPhase = 'power';
                shotCharging = true;
                chargeStartTime = Date.now();
                document.getElementById('message').textContent = 'HOLD for power... RELEASE to shoot!';
            } else if (freeKickPhase === 'power') {
                // Release shot
                fkPower = shotPower;
                freeKickPhase = 'flying';
                fkBallFlying = true;
                fkBallPos = { x: 400, y: 430 };
                shotCharging = false;
                shotPower = 0;
            }
        }

        function drawCelebration() {
            if (gameState === 'celebrating') {
                if (worldieGoalScored) {
                    // WORLDIE celebration - more intense!
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.4)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // More confetti for worldies
                    for (let i = 0; i < 40; i++) {
                        ctx.fillStyle = ['#ff4500', '#ffd700', '#fff', '#ff0'][Math.floor(Math.random() * 4)];
                        const size = 6 + Math.random() * 10;
                        ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, size, size);
                    }

                    // "WHAT A GOAL!" text effect
                    const time = Date.now() * 0.01;
                    ctx.save();
                    ctx.translate(canvas.width / 2, 80);
                    ctx.rotate(Math.sin(time) * 0.05);
                    ctx.font = 'bold 36px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#000';
                    ctx.fillText('WHAT A GOAL!', 2, 2);
                    ctx.fillStyle = '#ffd700';
                    ctx.fillText('WHAT A GOAL!', 0, 0);
                    ctx.restore();
                } else {
                    // Normal celebration
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    for (let i = 0; i < 20; i++) {
                        ctx.fillStyle = ['#c8102e', '#ffd700', '#fff'][Math.floor(Math.random() * 3)];
                        ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 8, 8);
                    }
                }
            }
        }

        function updateGame() {
            if (gameState === 'menu' || gameState === 'levelComplete' || gameState === 'gameOver' || gamePaused) return;

            // Update shot power
            if (shotCharging) {
                shotPower = Math.min(maxShotPower, (Date.now() - chargeStartTime) / 10);
            }

            const level = levels[currentLevel];

            // Move Salah (not in free kick)
            if (gameState === 'playing' && !level.freeKick) {
                if ((keys['arrowleft'] || keys['a']) && salah.x > 50) salah.x -= salah.speed;
                if ((keys['arrowright'] || keys['d']) && salah.x < 600) salah.x += salah.speed;
                if ((keys['arrowup'] || keys['w']) && salah.y > 50) salah.y -= salah.speed;
                if ((keys['arrowdown'] || keys['s']) && salah.y < 420) salah.y += salah.speed;

                if (touchMove.x !== 0 || touchMove.y !== 0) {
                    const newX = salah.x + touchMove.x * salah.speed;
                    const newY = salah.y + touchMove.y * salah.speed;
                    if (newX > 50 && newX < 600) salah.x = newX;
                    if (newY > 50 && newY < 420) salah.y = newY;
                }

                if (salah.hasBall) {
                    ball.x = salah.x + 20;
                    ball.y = salah.y + 45;
                }

                // Defenders with smarter AI - last defender acts as sweeper
                const defenderCount = level.defenders.length;
                level.defenders.forEach((defName, index) => {
                    const def = defenders[defName];
                    if (!def) return;

                    // Last defender is the sweeper - stays between Salah and goal
                    const isSweeper = defenderCount > 1 && index === defenderCount - 1;

                    let targetX, targetY;

                    if (isSweeper) {
                        // Sweeper positions between Salah and goal, slightly ahead
                        targetX = Math.min(salah.x + 120, 620); // Stay ahead of Salah but not too close to goal
                        targetY = salah.y; // Match Salah's Y position
                        // Move slower as sweeper
                        const dx = targetX - def.x;
                        const dy = targetY - def.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 10) {
                            def.x += (dx / dist) * def.speed * 0.6;
                            def.y += (dy / dist) * def.speed * 0.7;
                        }
                    } else {
                        // Regular defenders chase but with some offset to spread out
                        const spreadOffset = (index - defenderCount / 2) * 40;
                        targetX = salah.x;
                        targetY = salah.y + spreadOffset;
                        const dx = targetX - def.x;
                        const dy = targetY - def.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 5) {
                            def.x += (dx / dist) * def.speed;
                            def.y += (dy / dist) * def.speed;
                        }
                    }

                    // Tackle check
                    const tackleDistX = salah.x - def.x;
                    const tackleDistY = salah.y - def.y;
                    const tackleDist = Math.sqrt(tackleDistX * tackleDistX + tackleDistY * tackleDistY);
                    if (salah.hasBall && tackleDist < def.tackleRange) {
                        handleTackle(defName);
                    }
                });
            }

            // Update ball
            if (ball.active) {
                ball.x += ball.velocityX;
                ball.y += ball.velocityY;
                ball.velocityY += ball.curve; // Apply curve

                // Check wall collision (free kick)
                if (level.freeKick) {
                    for (const p of wallPlayers) {
                        if (ball.x > p.x && ball.x < p.x + p.width + 10 &&
                            ball.y > p.y && ball.y < p.y + p.height) {
                            ball.velocityX *= -0.3;
                            ball.velocityY = (Math.random() - 0.5) * 8;
                            document.getElementById('message').textContent = 'Blocked by the wall!';
                            gameState = 'saved';
                            setTimeout(() => handleMiss(false), 1000);
                            break;
                        }
                    }
                }

                // Post/bar hit check (before goal check)
                if (ball.x >= goal.x - 5 && ball.x <= goal.x + 15 && gameState === 'shooting') {
                    const topPost = goal.y + goal.postWidth;
                    const bottomPost = goal.y + goal.height - goal.postWidth;

                    // Crossbar hit (ball near top of goal)
                    if (ball.y >= goal.y - 10 && ball.y <= topPost + 5) {
                        ball.velocityX = -ball.velocityX * 0.6;
                        ball.velocityY = Math.abs(ball.velocityY) * 0.8 + 2;
                        screenShake = 8;
                        // Small chance to go in off the bar (lucky bounce)
                        if (Math.random() < 0.15) {
                            document.getElementById('message').textContent = 'OFF THE BAR AND IN!!!';
                            setTimeout(() => handleGoal(true), 300);
                        } else {
                            document.getElementById('message').textContent = 'OFF THE CROSSBAR!';
                            setTimeout(() => handleMiss(false), 1200);
                        }
                        gameState = 'saved';
                    }
                    // Left/right post hit
                    else if ((ball.y > goal.y - 5 && ball.y <= topPost + 10) ||
                             (ball.y >= bottomPost - 10 && ball.y < goal.y + goal.height + 5)) {
                        ball.velocityX = -ball.velocityX * 0.5;
                        ball.velocityY = (Math.random() - 0.5) * 6;
                        screenShake = 6;
                        // Small chance to go in off the post
                        if (Math.random() < 0.12) {
                            document.getElementById('message').textContent = 'OFF THE POST AND IN!!!';
                            setTimeout(() => handleGoal(true), 300);
                        } else {
                            document.getElementById('message').textContent = 'OFF THE POST!';
                            setTimeout(() => handleMiss(false), 1200);
                        }
                        gameState = 'saved';
                    }
                }

                // Ball past keeper check - if ball passes keeper, it's goal or wide (no phantom saves)
                const ballPastKeeper = ball.x > alisson.x + alisson.width;

                // Goal check - ball in goal area
                if (ball.x >= goal.x && ball.y > goal.y + goal.postWidth && ball.y < goal.y + goal.height - goal.postWidth) {
                    if (gameState === 'shooting') handleGoal();
                }
                // Ball past keeper but NOT in goal = wide/miss
                else if (ballPastKeeper && gameState === 'shooting') {
                    // Ball went past keeper but missed the goal
                    if (ball.y <= goal.y + goal.postWidth || ball.y >= goal.y + goal.height - goal.postWidth) {
                        document.getElementById('message').textContent = 'Wide!';
                        handleMiss(false);
                    }
                }

                // Save check - ONLY if ball hasn't passed keeper yet
                if (!ballPastKeeper) {
                    const ballRadius = ball.radius || 8;
                    const keeperHitBox = {
                        left: alisson.x - 3,
                        right: alisson.x + alisson.width + 3,
                        top: alisson.y - 3,
                        bottom: alisson.y + alisson.height + 3
                    };

                    if (ball.x + ballRadius > keeperHitBox.left &&
                        ball.x - ballRadius < keeperHitBox.right &&
                        ball.y + ballRadius > keeperHitBox.top &&
                        ball.y - ballRadius < keeperHitBox.bottom) {
                        if (gameState === 'shooting') {
                            // Ball definitely touches keeper - make save visual
                            ball.x = alisson.x + alisson.width / 2;
                            ball.y = alisson.y + alisson.height / 2;
                            ball.velocityX = -ball.velocityX * 0.4;
                            ball.velocityY = (Math.random() - 0.5) * 4;
                            handleMiss(true);
                        }
                    }
                }

                // Out of bounds (top/bottom only - sides handled above)
                if (ball.x > canvas.width + 50 || ball.y < -20 || ball.y > canvas.height + 20) {
                    if (gameState === 'shooting') handleMiss(false);
                }

                ball.velocityX *= 0.995;
                ball.velocityY *= 0.995;
            }

            // Update Alisson
            if (alisson.diving) {
                alisson.diveFrame++;
                const targetY = Math.max(goal.y, Math.min(goal.y + goal.height - alisson.height, alisson.targetY));
                // EASIER: Even slower dive speed (was 0.12, originally 0.15)
                alisson.y += (targetY - alisson.y) * 0.09;
            } else if (gameState === 'playing') {
                const targetY = ball.y - alisson.height / 2;
                const clampedTarget = Math.max(goal.y, Math.min(goal.y + goal.height - alisson.height, targetY));
                alisson.y += (clampedTarget - alisson.y) * level.keeperSpeed;
            }

            if (salah.kickFrame > 0) salah.kickFrame--;
            if (salah.celebrating) salah.celebrateFrame++;
        }

        function gameLoop() {
            // Record frames during shooting for replay
            if (gameState === 'shooting' && !isReplaying) {
                recordFrame();
            }

            // Handle replay mode
            if (isReplaying) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                drawReplayFrame();
                ctx.restore();
                requestAnimationFrame(gameLoop);
                return;
            }

            updateGame();

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Screen shake effect
            ctx.save();
            if (screenShake > 0) {
                const shakeX = (Math.random() - 0.5) * screenShake;
                const shakeY = (Math.random() - 0.5) * screenShake;
                ctx.translate(shakeX, shakeY);
                screenShake *= 0.9;
                if (screenShake < 0.5) screenShake = 0;
            }

            const level = levels[currentLevel];

            // FPV mode for free kicks (continue showing during celebrating/saved states)
            if (level?.freeKick && (gameState === 'freeKick' || gameState === 'celebrating' || gameState === 'saved' || fkBallFlying)) {
                // Update FPV free kick logic
                updateFPVFreeKick();
                // Draw FPV view
                drawFPVFreeKick();
                // Draw celebration overlay if celebrating
                drawCelebration();
            } else {
                // Normal game view
                drawField();

                // Draw defenders
                if (level && !level.freeKick) {
                    level.defenders.forEach(defName => {
                        const def = defenders[defName];
                        if (def) drawDefender(def.x, def.y, def.number, def.skin);
                    });
                }

                drawSalah(salah.x, salah.y);
                drawAlisson(alisson.x, alisson.y, alisson.diving, alisson.diveDirection);
                drawBall();
                drawPowerMeter();
                drawCelebration();
                drawTip();
            }

            // Draw streak counter if on a streak - centered at top to avoid lives
            if (currentStreak >= 2 && gameState !== 'menu') {
                const streakText = `üî• x${currentStreak}`;
                const comboText = comboMultiplier > 1 ? ` (${comboMultiplier}x)` : '';
                ctx.font = 'bold 14px monospace';
                const fullText = streakText + comboText;
                const textWidth = ctx.measureText(fullText).width + 20;
                const streakX = (canvas.width / 2) - (textWidth / 2);

                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(streakX, 5, textWidth, 25);
                ctx.fillStyle = currentStreak >= 5 ? '#ff4444' : currentStreak >= 3 ? '#ffd700' : '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(fullText, canvas.width / 2, 22);
                ctx.textAlign = 'left';
            }

            // Draw pause overlay with big play button
            if (gamePaused && gameState !== 'menu' && gameState !== 'gameOver') {
                // Gray overlay
                ctx.fillStyle = 'rgba(0,0,0,0.75)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Big play button circle
                const btnX = canvas.width / 2;
                const btnY = canvas.height / 2;
                const btnRadius = 60;

                // Button background
                ctx.beginPath();
                ctx.arc(btnX, btnY, btnRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#c8102e';
                ctx.fill();
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 4;
                ctx.stroke();

                // Play triangle
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(btnX - 15, btnY - 25);
                ctx.lineTo(btnX - 15, btnY + 25);
                ctx.lineTo(btnX + 25, btnY);
                ctx.closePath();
                ctx.fill();

                // Text
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 24px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', btnX, btnY - 90);
                ctx.font = '10px "Press Start 2P", monospace';
                ctx.fillStyle = '#fff';
                ctx.fillText('TAP TO PLAY', btnX, btnY + 90);
                ctx.textAlign = 'left';
            }

            ctx.restore();

            requestAnimationFrame(gameLoop);
        }

        // Draw tips at bottom of screen
        function drawTip() {
            if (gameState === 'playing' || gameState === 'freeKick') {
                tipTimer++;
                if (tipTimer > 600) { // Change tip every 10 seconds
                    tipTimer = 0;
                    currentTip = (currentTip + 1) % tips.length;
                }

                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, canvas.height - 25, canvas.width, 25);
                ctx.fillStyle = '#ffd700';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(tips[currentTip], canvas.width / 2, canvas.height - 8);
                ctx.textAlign = 'left';
            }
        }

        // Intro scene
        const introCanvas = document.getElementById('introCanvas');
        const introCtx = introCanvas ? introCanvas.getContext('2d') : null;

        let introKeeperY = 150; // Keeper position for diving
        let introKeeperDiving = false;

        function drawIntroScene() {
            if (!introCtx) return;
            introCtx.fillStyle = '#2d5a27';
            introCtx.fillRect(0, 0, 400, 300);

            // Grass stripes
            introCtx.fillStyle = '#347a2c';
            for (let i = 0; i < 400; i += 40) introCtx.fillRect(i, 0, 20, 300);

            // Goal posts
            introCtx.fillStyle = '#fff';
            introCtx.fillRect(350, 100, 6, 100); // Left post
            introCtx.fillRect(350, 100, 45, 6);   // Crossbar
            introCtx.fillRect(350, 194, 45, 6);   // Bottom bar

            // Net (behind goal)
            introCtx.strokeStyle = 'rgba(255,255,255,0.4)';
            introCtx.lineWidth = 1;
            for (let i = 105; i < 195; i += 10) {
                introCtx.beginPath();
                introCtx.moveTo(356, i);
                introCtx.lineTo(390, i);
                introCtx.stroke();
            }
            for (let i = 360; i < 395; i += 10) {
                introCtx.beginPath();
                introCtx.moveTo(i, 105);
                introCtx.lineTo(i, 195);
                introCtx.stroke();
            }

            // Draw pixel Salah based on phase
            const salahX = Math.min(introBallX - 20, 280);

            if (introPhase === 'run' || introPhase === 'kick') {
                // Running Salah
                const bounce = Math.sin(introFrame * 0.3) * 3;
                introCtx.fillStyle = '#1a1a1a';
                introCtx.fillRect(salahX + 4, 135 + bounce, 16, 8);
                introCtx.fillStyle = '#c68642';
                introCtx.fillRect(salahX + 6, 140 + bounce, 12, 12);
                introCtx.fillStyle = '#c8102e';
                introCtx.fillRect(salahX + 4, 152 + bounce, 16, 14);
                introCtx.fillStyle = '#c68642';
                introCtx.fillRect(salahX + 6, 166 + bounce, 5, 8);
                introCtx.fillRect(salahX + 13, 166 + bounce, 5, 8);
            }

            if (introPhase === 'goal' || introPhase === 'celebrate') {
                // Celebrating Salah - sliding on knees with arms up
                const pump = Math.sin(introFrame * 0.15) * 3;
                introCtx.fillStyle = '#1a1a1a';
                introCtx.fillRect(salahX + 4, 145, 16, 8); // Hair
                introCtx.fillStyle = '#c68642';
                introCtx.fillRect(salahX + 6, 150, 12, 12); // Face
                introCtx.fillStyle = '#c8102e';
                introCtx.fillRect(salahX + 4, 162, 16, 14); // Body
                // Arms raised in celebration
                introCtx.fillRect(salahX - 4, 150 - pump, 8, 14);
                introCtx.fillRect(salahX + 20, 150 + pump, 8, 14);
                // Kneeling legs
                introCtx.fillStyle = '#c68642';
                introCtx.fillRect(salahX + 4, 176, 16, 6);
            }

            // Keeper (Alisson) - diving/defeated
            if (introPhase === 'goal' || introPhase === 'celebrate') {
                // Alisson on knees, defeated
                introCtx.fillStyle = '#32CD32';
                introCtx.fillRect(338, 175, 20, 12); // Body lying
                introCtx.fillStyle = '#d4a574';
                introCtx.fillRect(335, 175, 8, 8); // Head down
                introCtx.fillStyle = '#FFD700'; // Gloves
                introCtx.fillRect(330, 180, 6, 6);
                introCtx.fillRect(356, 180, 6, 6);
            } else if (introPhase === 'kick') {
                // Alisson diving (wrong way!)
                introCtx.fillStyle = '#32CD32';
                introCtx.fillRect(335, introKeeperY + 20, 18, 10); // Diving body
                introCtx.fillStyle = '#d4a574';
                introCtx.fillRect(337, introKeeperY + 15, 8, 8); // Head
                introCtx.fillStyle = '#FFD700';
                introCtx.fillRect(332, introKeeperY + 10, 8, 10); // Gloves reaching
            } else {
                // Standing ready
                introCtx.fillStyle = '#32CD32';
                introCtx.fillRect(338, 135, 12, 30);
                introCtx.fillStyle = '#d4a574';
                introCtx.fillRect(340, 128, 8, 10);
                introCtx.fillStyle = '#FFD700';
                introCtx.fillRect(334, 138, 6, 8);
                introCtx.fillRect(348, 138, 6, 8);
            }

            // Ball - at Salah's feet during run, then flying during kick/goal
            let ballDrawX, ballDrawY;
            if (introPhase === 'run') {
                // Ball at Salah's feet while dribbling
                const bounce = Math.sin(introFrame * 0.3) * 3;
                ballDrawX = salahX + 18; // At his feet
                ballDrawY = 172 + bounce; // Bouncing with him
            } else {
                ballDrawX = introBallX;
                ballDrawY = introBallY;
            }

            introCtx.fillStyle = '#fff';
            introCtx.beginPath();
            introCtx.arc(ballDrawX, ballDrawY, 6, 0, Math.PI * 2);
            introCtx.fill();
            introCtx.fillStyle = '#333';
            introCtx.beginPath();
            introCtx.arc(ballDrawX - 2, ballDrawY - 2, 2, 0, Math.PI * 2);
            introCtx.fill();

            // Title
            introCtx.fillStyle = '#c8102e';
            introCtx.font = 'bold 20px monospace';
            introCtx.textAlign = 'center';
            introCtx.fillText('MO SALAH', 200, 40);
            introCtx.fillStyle = '#ffd700';
            introCtx.font = '14px monospace';
            introCtx.fillText('GOAL MACHINE', 200, 60);
            introCtx.textAlign = 'left';

            if (introPhase === 'goal' || introPhase === 'celebrate') {
                // Net bulge effect - ball is IN the net
                introCtx.fillStyle = 'rgba(255,215,0,0.3)';
                introCtx.fillRect(0, 0, 400, 300);

                // GOAL text
                introCtx.fillStyle = '#ffd700';
                introCtx.font = 'bold 28px monospace';
                introCtx.textAlign = 'center';
                introCtx.strokeStyle = '#000';
                introCtx.lineWidth = 3;
                introCtx.strokeText('GOAL!', 200, 250);
                introCtx.fillText('GOAL!', 200, 250);

                // Confetti
                for (let i = 0; i < 15; i++) {
                    introCtx.fillStyle = ['#c8102e', '#ffd700', '#fff'][i % 3];
                    const cx = (introFrame * 2 + i * 30) % 400;
                    const cy = (introFrame + i * 20) % 300;
                    introCtx.fillRect(cx, cy, 4, 4);
                }
                introCtx.textAlign = 'left';
            }
        }

        function updateIntro() {
            introFrame++;

            if (introPhase === 'run') {
                introBallX += 1.5;
                // Ball stays at Salah's feet during dribbling
                introBallY = 170 + Math.sin(introFrame * 0.4) * 2; // Slight dribble bounce
                if (introBallX > 300) {
                    introPhase = 'kick';
                    introKeeperDiving = true;
                }
            } else if (introPhase === 'kick') {
                introBallX += 5;
                // Ball curves into top corner
                introBallY = 150 + Math.sin((introBallX - 300) * 0.03) * -30;
                // Keeper dives wrong way
                if (introKeeperDiving) {
                    introKeeperY += 2; // Diving down while ball goes up!
                }
                // Ball reaches inside the goal (past the posts)
                if (introBallX > 375) {
                    introPhase = 'goal';
                    introBallX = 375; // Ball rests in back of net
                    introBallY = 130; // Top corner
                    setTimeout(() => { introPhase = 'celebrate'; }, 1500);
                }
            } else if (introPhase === 'celebrate') {
                if (introFrame > 500) {
                    skipIntro();
                }
            }
        }

        function introLoop() {
            if (!introActive) return;
            updateIntro();
            drawIntroScene();
            requestAnimationFrame(introLoop);
        }

        function skipIntro() {
            introActive = false;
            document.getElementById('introOverlay').classList.add('hidden');
            document.getElementById('startOverlay').classList.remove('hidden');
        }

        // Skip intro on button click or key press
        document.getElementById('skipIntroBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            skipIntro();
        });
        document.getElementById('skipIntroBtn').addEventListener('touchstart', (e) => {
            e.stopPropagation();
            skipIntro();
        });
        document.addEventListener('keydown', () => { if (introActive) skipIntro(); });

        // Menu handlers
        document.getElementById('startBtn').addEventListener('click', () => {
            playerName = document.getElementById('playerName').value.trim() || 'PLAYER';
            document.getElementById('startOverlay').classList.add('hidden');
            totalScore = 0;
            lives = 5;
            currentStreak = 0;
            bestStreak = 0;
            comboMultiplier = 1;
            deathCount = 0;
            document.getElementById('totalScore').textContent = '0';
            startLevel(0);
        });

        document.getElementById('nextLevelBtn').addEventListener('click', () => {
            // Show ad between levels (every other level for better UX)
            if (currentLevel > 0 && currentLevel % 2 === 0) {
                showAd(() => {
                    startLevel(currentLevel + 1);
                });
            } else {
                startLevel(currentLevel + 1);
            }
        });

        document.getElementById('extraLifeBtn').addEventListener('click', () => {
            showRewardedAd(() => {
                lives++;
                // STREAK PENALTY: Using ad life resets your current streak!
                const hadStreak = currentStreak >= 2;
                currentStreak = 0;
                comboMultiplier = 1;
                // Pause game after ad so player can prepare
                setTimeout(() => {
                    gamePaused = true;
                    document.getElementById('pauseBtn').textContent = '‚ñ∂';
                    const msg = hadStreak ? '+1 LIFE! (Streak reset) Tap ‚ñ∂ when ready!' : '+1 LIFE! Tap ‚ñ∂ when ready!';
                    document.getElementById('message').textContent = msg;
                }, 100);
            });
        });

        document.getElementById('continueAdBtn').addEventListener('click', () => {
            showRewardedAd(() => {
                // Give player another chance - but streak resets as penalty
                document.getElementById('gameOverOverlay').classList.add('hidden');
                lives = 1;
                // STREAK PENALTY: Using ad to continue resets streak!
                currentStreak = 0;
                comboMultiplier = 1;
                resetPositions();
                // Pause so they can prepare
                setTimeout(() => {
                    gamePaused = true;
                    document.getElementById('pauseBtn').textContent = '‚ñ∂';
                    document.getElementById('message').textContent = 'Streak reset! Tap ‚ñ∂ to continue!';
                }, 100);
            });
        });

        document.getElementById('playAgainBtn').addEventListener('click', () => {
            // Show ad on replay
            showAd(() => {
                document.getElementById('gameOverOverlay').classList.add('hidden');
                totalScore = 0;
                lives = 5;
                currentStreak = 0;
                bestStreak = 0;
                comboMultiplier = 1;
                deathCount = 0;
                document.getElementById('totalScore').textContent = '0';
                startLevel(0);
            });
        });

        document.getElementById('mainMenuBtn').addEventListener('click', () => {
            document.getElementById('gameOverOverlay').classList.add('hidden');
            document.getElementById('startOverlay').classList.remove('hidden');
            displayLeaderboard('leaderboard');
        });

        // Initialize
        document.getElementById('startOverlay').classList.add('hidden'); // Hide until intro done
        displayLeaderboard('leaderboard');
        introLoop(); // Start intro
        gameLoop();
    </script>
</body>
</html>
