<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1a1a2e">
    <title>Mo Salah Goal Machine</title>
    <!-- GameMonetize SDK for Ads -->
    <script src="https://api.gamemonetize.com/sdk.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Press Start 2P', monospace;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .game-container {
            text-align: center;
            padding: 5px;
            width: 100%;
            max-width: 100vw;
            max-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        h1 {
            color: #c8102e;
            font-size: clamp(12px, 4vw, 20px);
            margin-bottom: 5px;
            text-shadow: 2px 2px 0 #000;
            font-family: 'Press Start 2P', monospace;
        }

        .score-board {
            display: flex;
            justify-content: center;
            gap: clamp(8px, 2vw, 20px);
            margin-bottom: 5px;
            font-family: 'Press Start 2P', monospace;
            flex-wrap: wrap;
        }

        .score {
            color: #fff;
            font-size: clamp(8px, 2.5vw, 12px);
        }

        .goals { color: #4ade80; }
        .saves { color: #f87171; }
        .level { color: #60a5fa; }
        .total { color: #ffd700; }

        #canvasWrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            border: 3px solid #c8102e;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(200, 16, 46, 0.5);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            touch-action: none;
            max-width: 100%;
            height: auto;
        }

        .fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #ffd700;
            color: #ffd700;
            padding: 8px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            z-index: 50;
        }

        .instructions {
            color: #888;
            font-size: clamp(6px, 1.5vw, 8px);
            margin-top: 5px;
            font-family: 'Press Start 2P', monospace;
            line-height: 1.6;
        }

        .mobile-controls {
            display: none;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            padding: 0 10px;
            width: 100%;
            max-width: 800px;
            flex-shrink: 0;
        }

        @media (pointer: coarse) {
            .mobile-controls { display: flex; }
            .instructions { display: none; }
        }

        .joystick-area {
            width: clamp(70px, 15vw, 120px);
            height: clamp(70px, 15vw, 120px);
            background: rgba(255,255,255,0.15);
            border-radius: 50%;
            position: relative;
            border: 3px solid rgba(255,255,255,0.4);
            flex-shrink: 0;
        }

        .joystick-knob {
            width: 45%;
            height: 45%;
            background: rgba(200, 16, 46, 0.9);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid #fff;
        }

        .shoot-btn {
            width: clamp(60px, 14vw, 100px);
            height: clamp(60px, 14vw, 100px);
            background: linear-gradient(145deg, #c8102e, #a00d24);
            border-radius: 50%;
            border: 4px solid #ffd700;
            color: #fff;
            font-family: 'Press Start 2P', monospace;
            font-size: clamp(8px, 2vw, 12px);
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(200, 16, 46, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        /* Landscape mobile - controls on OPPOSITE sides for two-handed play */
        @media (orientation: landscape) and (max-height: 500px) {
            .game-container {
                flex-direction: row;
                padding: 5px;
                justify-content: space-between;
            }
            #canvasWrapper {
                order: 2;
                flex: 1;
                max-width: calc(100% - 180px);
            }
            .mobile-controls {
                display: flex !important;
                flex-direction: row;
                width: 100%;
                height: auto;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                justify-content: space-between;
                padding: 10px 20px;
                background: transparent;
                pointer-events: none;
            }
            .mobile-controls > * {
                pointer-events: auto;
            }
            .joystick-area {
                order: 1; /* LEFT side */
            }
            .shoot-btn {
                order: 2; /* RIGHT side */
            }
            h1, .score-board, .message, .instructions {
                position: absolute;
            }
            h1 { top: 5px; left: 50%; transform: translateX(-50%); font-size: 10px; z-index: 10; }
            .score-board { top: 5px; right: 10px; font-size: 8px; gap: 10px; z-index: 10; }
            .message { top: 25px; left: 50%; transform: translateX(-50%); font-size: 8px; z-index: 10; }
        }

        /* Portrait mobile - stack vertically */
        @media (orientation: portrait) and (max-width: 600px) {
            .game-container {
                padding: 5px;
                justify-content: flex-start;
                padding-top: env(safe-area-inset-top, 10px);
            }
            h1 { font-size: 14px; margin-bottom: 3px; }
            .score-board { gap: 10px; margin-bottom: 3px; }
            .score { font-size: 9px; }
            .mobile-controls {
                margin-top: 8px;
                padding: 0 15px;
            }
        }

        /* Very small screens */
        @media (max-width: 380px) {
            h1 { font-size: 11px; }
            .score { font-size: 7px; }
            .joystick-area { width: 65px; height: 65px; }
            .shoot-btn { width: 55px; height: 55px; font-size: 7px; }
        }

        /* Large screens / desktop */
        @media (min-width: 1024px) {
            .game-container { padding: 20px; }
            h1 { font-size: 24px; }
            .score { font-size: 14px; }
        }

        .message {
            color: #ffd700;
            font-size: 11px;
            margin-top: 10px;
            font-family: 'Press Start 2P', monospace;
            min-height: 20px;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .overlay.hidden { display: none; }

        .menu {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 4px solid #c8102e;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .menu h2 {
            color: #c8102e;
            font-size: 18px;
            margin-bottom: 20px;
            font-family: 'Press Start 2P', monospace;
        }

        .menu input {
            padding: 12px;
            font-size: 14px;
            font-family: 'Press Start 2P', monospace;
            border: 3px solid #c8102e;
            border-radius: 8px;
            margin: 10px 0;
            width: 200px;
            text-align: center;
        }

        .menu button {
            padding: 15px 30px;
            font-size: 12px;
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(145deg, #c8102e, #a00d24);
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.1s;
        }

        .menu button:hover {
            transform: scale(1.05);
        }

        .leaderboard {
            margin-top: 20px;
            text-align: left;
        }

        .leaderboard h3 {
            color: #ffd700;
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
        }

        .leaderboard-entry {
            color: #fff;
            font-size: 10px;
            padding: 5px 0;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
        }

        .leaderboard-entry.gold { color: #ffd700; }
        .leaderboard-entry.silver { color: #c0c0c0; }
        .leaderboard-entry.bronze { color: #cd7f32; }

        /* Force GameMonetize ads to appear ABOVE game overlays */
        #GameMonetize-container,
        [id*="GameMonetize"],
        [class*="gamemonetize"],
        iframe[src*="gamemonetize"],
        div[style*="z-index: 99999"],
        div[style*="z-index:99999"] {
            z-index: 999999 !important;
        }

        /* When ad is playing, hide our overlays */
        body.ad-playing .overlay {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>MO SALAH GOAL MACHINE</h1>
        <div class="score-board">
            <span class="score level">LVL: <span id="level">1</span></span>
            <span class="score goals">GOALS: <span id="goals">0</span>/<span id="target">2</span></span>
            <span class="score total">PTS: <span id="totalScore">0</span></span>
        </div>
        <div id="canvasWrapper">
            <canvas id="gameCanvas" width="800" height="500"></canvas>
            <button class="fullscreen-btn" id="fullscreenBtn" title="Fullscreen">‚õ∂</button>
        </div>
        <div class="message" id="message">Hold SHOOT to power up!</div>
        <div class="instructions">
            ARROWS/WASD - Move | HOLD SPACE - Power shot | Avoid defenders!
        </div>
        <div class="mobile-controls">
            <div class="joystick-area" id="joystick">
                <div class="joystick-knob" id="knob"></div>
            </div>
            <button class="shoot-btn" id="shootBtn">SHOOT</button>
        </div>
    </div>

    <!-- Start Menu Overlay -->
    <div class="overlay hidden" id="startOverlay">
        <div class="menu">
            <h2>MO SALAH<br>GOAL MACHINE</h2>
            <p style="color:#fff;font-size:10px;margin:15px 0;">Enter your name:</p>
            <input type="text" id="playerName" placeholder="YOUR NAME" maxlength="12">
            <br>
            <button id="startBtn">START GAME</button>
            <div class="leaderboard" id="leaderboard"></div>
        </div>
    </div>

    <!-- Ad Container -->
    <div class="overlay hidden" id="adOverlay">
        <div class="menu" style="padding:20px;min-width:280px;">
            <p style="color:#ffd700;font-size:14px;margin-bottom:10px;" id="adTitle">BONUS INCOMING!</p>
            <p style="color:#fff;font-size:24px;margin:20px 0;" id="adCountdown">5</p>
            <div id="gamemonetize-ad" style="min-height:80px;display:flex;align-items:center;justify-content:center;">
                <div style="color:#888;font-size:10px;" id="adStatus">Loading...</div>
            </div>
            <button id="closeAdBtn" style="margin-top:15px;padding:10px 20px;font-size:10px;background:#666;display:none;">SKIP</button>
        </div>
    </div>

    <!-- Level Complete Overlay -->
    <div class="overlay hidden" id="levelOverlay">
        <div class="menu">
            <h2 id="levelTitle">LEVEL COMPLETE!</h2>
            <p style="color:#4ade80;font-size:14px;margin:15px 0;" id="levelScore"></p>
            <p style="color:#fff;font-size:10px;margin:15px 0;" id="levelDesc"></p>
            <button id="nextLevelBtn">NEXT LEVEL</button>
            <button id="extraLifeBtn" style="background:linear-gradient(145deg,#22c55e,#16a34a);margin-top:5px;">üì∫ WATCH AD +1 LIFE</button>
        </div>
    </div>

    <!-- Game Over Overlay -->
    <div class="overlay hidden" id="gameOverOverlay">
        <div class="menu">
            <h2>GAME OVER</h2>
            <p style="color:#ffd700;font-size:16px;margin:15px 0;">Final Score: <span id="finalScore">0</span></p>
            <p style="color:#fff;font-size:10px;margin:15px 0;" id="gameOverMsg"></p>
            <div style="margin:15px 0;">
                <p style="color:#fff;font-size:8px;margin-bottom:8px;">SHARE YOUR SCORE:</p>
                <button onclick="shareScore('twitter')" style="padding:8px 12px;font-size:10px;margin:3px;">üê¶ Twitter</button>
                <button onclick="shareScore('whatsapp')" style="padding:8px 12px;font-size:10px;margin:3px;background:#25D366;">üí¨ WhatsApp</button>
                <button onclick="shareScore('copy')" style="padding:8px 12px;font-size:10px;margin:3px;background:#666;">üìã Copy</button>
            </div>
            <button id="continueAdBtn" style="background:linear-gradient(145deg,#22c55e,#16a34a);">üì∫ WATCH AD TO CONTINUE</button>
            <button id="playAgainBtn">PLAY AGAIN</button>
            <button id="mainMenuBtn">MAIN MENU</button>
            <div class="leaderboard" id="gameOverLeaderboard"></div>
        </div>
    </div>

    <!-- Intro Overlay -->
    <div class="overlay" id="introOverlay">
        <div style="text-align:center;">
            <canvas id="introCanvas" width="400" height="300" style="border-radius:8px;"></canvas>
            <button id="skipIntroBtn" style="margin-top:20px;padding:15px 40px;font-size:14px;font-family:'Press Start 2P',monospace;background:linear-gradient(145deg,#c8102e,#a00d24);color:#fff;border:4px solid #ffd700;border-radius:8px;cursor:pointer;animation:pulse 1s infinite;">SKIP INTRO</button>
        </div>
    </div>
    <style>
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px #ffd700; }
            50% { transform: scale(1.05); box-shadow: 0 0 20px #ffd700; }
        }
    </style>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ========== RESPONSIVE SCALING ==========
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 500;
        let canvasScale = 1;

        function resizeCanvas() {
            const wrapper = document.getElementById('canvasWrapper');
            const container = document.querySelector('.game-container');

            // Get available space
            const maxWidth = Math.min(window.innerWidth - 20, 800);
            const maxHeight = window.innerHeight - 200; // Leave room for controls & UI

            // Calculate scale to fit
            const scaleX = maxWidth / GAME_WIDTH;
            const scaleY = maxHeight / GAME_HEIGHT;
            canvasScale = Math.min(scaleX, scaleY, 1); // Don't scale up beyond 1

            // Apply size via CSS (keeps internal resolution)
            canvas.style.width = (GAME_WIDTH * canvasScale) + 'px';
            canvas.style.height = (GAME_HEIGHT * canvasScale) + 'px';

            // Also resize intro canvas
            const introCanvas = document.getElementById('introCanvas');
            if (introCanvas) {
                const introScale = Math.min(canvasScale * 1.2, 1);
                introCanvas.style.width = (400 * introScale) + 'px';
                introCanvas.style.height = (300 * introScale) + 'px';
            }
        }

        // Fullscreen support
        function toggleFullscreen() {
            const elem = document.documentElement;
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
        }

        document.getElementById('fullscreenBtn')?.addEventListener('click', toggleFullscreen);

        // Handle resize and orientation changes
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100); // Delay for orientation to settle
        });
        document.addEventListener('fullscreenchange', () => {
            setTimeout(resizeCanvas, 100);
        });

        // Prevent unwanted touch behaviors
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('.overlay input')) return; // Allow scrolling in inputs
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('gesturestart', (e) => e.preventDefault());
        document.addEventListener('gesturechange', (e) => e.preventDefault());

        // Initial resize
        resizeCanvas();

        // ========== LEVEL CONFIGURATIONS ==========
        // Level configurations - easier start, gradual difficulty
        const levels = [
            { name: "Warm Up", target: 2, defenders: [], keeperSpeed: 0.012, desc: "Just you and Alisson. Easy start!" },
            { name: "Getting Started", target: 2, defenders: ['konate'], keeperSpeed: 0.015, defenderSpeed: 2.0, desc: "Konate joins but he's taking it easy!" },
            { name: "Van Dijk!", target: 2, defenders: ['konate', 'vandijk'], keeperSpeed: 0.018, defenderSpeed: 2.3, desc: "The big man Van Dijk arrives!" },
            { name: "Robertson Joins", target: 3, defenders: ['konate', 'vandijk', 'robertson'], keeperSpeed: 0.022, defenderSpeed: 2.5, desc: "Robertson adds to the defense!" },
            { name: "FREE KICK!", target: 1, defenders: [], keeperSpeed: 0.025, freeKick: true, wallSize: 3, desc: "Bonus Round! Bend it like Salah!" },
            { name: "Stepping Up", target: 3, defenders: ['konate', 'vandijk'], keeperSpeed: 0.028, defenderSpeed: 2.8, desc: "Defenders are getting serious!" },
            { name: "Full Squad", target: 3, defenders: ['konate', 'vandijk', 'robertson', 'bradley'], keeperSpeed: 0.032, defenderSpeed: 3.0, desc: "Bradley completes the back four!" },
            { name: "FINAL FREE KICK", target: 1, defenders: [], keeperSpeed: 0.035, freeKick: true, wallSize: 4, desc: "Bigger wall! Curve it in!" },
            { name: "SUDDEN DEATH", target: 999, defenders: ['konate', 'vandijk', 'robertson', 'bradley'], keeperSpeed: 0.04, defenderSpeed: 3.3, suddenDeath: true, desc: "ENDLESS MODE! Score until you drop!" }
        ];

        // Game state
        let currentLevel = 0;
        let levelGoals = 0;
        let totalScore = 0;
        let lives = 5;
        let playerName = '';
        let gameState = 'menu'; // menu, playing, shooting, celebrating, saved, tackled, freeKick, gameOver
        let gamePaused = false; // Pause game during ads/overlays

        // Free kick state - FPV (First Person View) system
        let freeKickPhase = 'aim'; // aim, power, flying
        let fkTarget = { x: 400, y: 200 }; // Where you're aiming (screen coords)
        let fkBallPos = { x: 400, y: 450, z: 0 }; // Ball 3D position for animation
        let fkBallVel = { x: 0, y: 0, z: 0 };
        let fkPower = 0;
        let fkCurve = 0;
        let wallPlayers = [];
        let fkKeeperPos = { x: 400, y: 180 }; // Keeper position in FPV
        let fkKeeperDiving = false;
        let fkKeeperDiveDir = 0;

        // Salah (player)
        const salah = {
            x: 200, y: 250, width: 32, height: 48, speed: 4,
            hasBall: true, kickFrame: 0, celebrating: false, celebrateFrame: 0
        };

        // Ball
        const ball = {
            x: 220, y: 270, radius: 8,
            velocityX: 0, velocityY: 0, curve: 0, active: false
        };

        // Alisson
        const alisson = {
            x: 700, y: 250, width: 36, height: 52,
            targetY: 250, speed: 3, diving: false, diveDirection: 0, diveFrame: 0
        };

        // Defenders
        const defenders = {
            konate: { x: 500, y: 250, speed: 2.5, tackleRange: 35, number: 5, skin: '#3d2314' },
            vandijk: { x: 450, y: 180, speed: 2.2, tackleRange: 38, number: 4, skin: '#d4a574' },
            robertson: { x: 480, y: 320, speed: 2.8, tackleRange: 32, number: 26, skin: '#f5d5c8' },
            bradley: { x: 420, y: 250, speed: 2.6, tackleRange: 30, number: 66, skin: '#f5d5c8' }
        };

        // Goal
        const goal = { x: 740, y: 150, width: 50, height: 200, postWidth: 8 };

        // Shot power
        let shotCharging = false;
        let shotPower = 0;
        let maxShotPower = 100;
        let chargeStartTime = 0;

        // Commentary
        const goalMessages = [
            'GOAL! The Egyptian King strikes!', 'SALAAAAH! What a finish!',
            'He makes it look so easy!', 'Running down the wing! SALAH!',
            'The Pharaoh has spoken!', 'Unstoppable from Mo Salah!',
            'Clinical finish! Pure class!', 'Alisson had no chance!',
            'WORLD CLASS!', 'The King of Egypt!'
        ];
        const saveMessages = [
            'SAVED by Alisson!', 'Great stop from Alisson!',
            'The Brazilian says NO!', 'Alisson stands tall!',
            'Denied by the keeper!', 'What a save! Alisson!'
        ];
        const missMessages = [
            'Over the bar! Too much power!', 'Blazed it over! So close!',
            'Into the stands!', 'Skied it!', 'Way too much on that one!'
        ];
        const tackleMessages = [
            'TACKLED!', 'Dispossessed!', 'Great defending!',
            'Ball won cleanly!', 'Reads it perfectly!'
        ];
        const freeKickMessages = [
            'WHAT A FREE KICK!', 'Bend it like Salah!',
            'Curled into the corner!', 'The wall had no chance!',
            'Absolutely magnificent!'
        ];

        function randomMessage(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // Global Leaderboard using Dreamlo
        const DREAMLO_PRIVATE = 'plQDO2UdfEytCaRU9D0M3QjzvR1a9VJkaQBeFOXWkNUg';
        const DREAMLO_PUBLIC = '697e8e208f40bb1184cada44';
        let globalLeaderboard = [];

        async function fetchLeaderboard() {
            try {
                const response = await fetch(`https://www.dreamlo.com/lb/${DREAMLO_PUBLIC}/json`);
                const data = await response.json();
                if (data.dreamlo && data.dreamlo.leaderboard && data.dreamlo.leaderboard.entry) {
                    let entries = data.dreamlo.leaderboard.entry;
                    // Handle single entry (not array)
                    if (!Array.isArray(entries)) entries = [entries];
                    globalLeaderboard = entries.map(e => ({
                        name: e.name,
                        score: parseInt(e.score)
                    }));
                } else {
                    globalLeaderboard = [];
                }
            } catch (err) {
                console.log('Leaderboard fetch error:', err);
                // Fallback to local storage
                const data = localStorage.getItem('salahLeaderboard');
                globalLeaderboard = data ? JSON.parse(data) : [];
            }
            return globalLeaderboard;
        }

        async function saveScore(name, score) {
            // Save to local storage as backup
            const local = localStorage.getItem('salahLeaderboard');
            const leaderboard = local ? JSON.parse(local) : [];
            leaderboard.push({ name, score, date: Date.now() });
            leaderboard.sort((a, b) => b.score - a.score);
            localStorage.setItem('salahLeaderboard', JSON.stringify(leaderboard.slice(0, 50)));

            // Save to global Dreamlo leaderboard
            try {
                const safeName = encodeURIComponent(name.replace(/[^a-zA-Z0-9]/g, '').substring(0, 12) || 'PLAYER');
                await fetch(`https://www.dreamlo.com/lb/${DREAMLO_PRIVATE}/add/${safeName}/${score}`);
                console.log('Score saved globally!');
            } catch (err) {
                console.log('Error saving to global leaderboard:', err);
            }
        }

        async function displayLeaderboard(elementId) {
            const container = document.getElementById(elementId);
            if (!container) return;

            container.innerHTML = '<h3>GLOBAL LEADERBOARD</h3><p style="color:#888;font-size:10px;">Loading...</p>';

            await fetchLeaderboard();

            let html = '<h3>GLOBAL LEADERBOARD</h3>';
            const top10 = globalLeaderboard.slice(0, 10);
            if (top10.length === 0) {
                html += '<p style="color:#888;font-size:10px;">No scores yet! Be the first!</p>';
            } else {
                top10.forEach((entry, i) => {
                    let cls = '';
                    if (i === 0) cls = 'gold';
                    else if (i === 1) cls = 'silver';
                    else if (i === 2) cls = 'bronze';
                    html += `<div class="leaderboard-entry ${cls}">
                        <span>${i + 1}. ${entry.name}</span>
                        <span>${entry.score}</span>
                    </div>`;
                });
            }
            container.innerHTML = html;
        }

        // GameMonetize Ads Integration
        const GAME_ID = '4kci7og3klgj0ivy2wz3gdvd9dth5e7n';
        let adCallback = null;
        let adsWatched = 0;
        let sdkReady = false;

        // Initialize GameMonetize SDK
        function initGameMonetizeSDK() {
            if (typeof GameMonetize !== 'undefined') {
                GameMonetize.init({
                    gameId: GAME_ID,
                    onEvent: function(event) {
                        console.log('GameMonetize event:', event.name);
                        if (event.name === 'SDK_READY') {
                            sdkReady = true;
                            console.log('GameMonetize SDK ready!');
                        } else if (event.name === 'AD_SUCCESS' || event.name === 'AD_COMPLETED') {
                            adsWatched++;
                            document.getElementById('adOverlay').classList.add('hidden');
                            if (adCallback) adCallback(true);
                        } else if (event.name === 'AD_FAILED' || event.name === 'AD_REJECTED' || event.name === 'AD_DISMISS') {
                            console.log('Ad not available or dismissed');
                            document.getElementById('adOverlay').classList.add('hidden');
                            if (adCallback) adCallback(true); // Continue anyway
                        }
                    }
                });
            } else if (typeof sdk !== 'undefined' && sdk.init) {
                // Alternative SDK pattern
                sdk.init(GAME_ID);
                sdkReady = true;
            } else {
                console.log('GameMonetize SDK not found - ads will be simulated');
            }
        }

        // Try to init SDK when page loads
        window.addEventListener('load', initGameMonetizeSDK);

        let adCountdownInterval = null;

        // Track which overlay was showing before ad
        let overlayBeforeAd = null;

        function showAd(onComplete, isRewarded = false) {
            adCallback = onComplete;
            gamePaused = true; // PAUSE THE GAME

            // Remember which overlay was showing and hide ALL overlays for the ad
            overlayBeforeAd = null;
            ['levelOverlay', 'gameOverOverlay', 'startOverlay'].forEach(id => {
                const el = document.getElementById(id);
                if (el && !el.classList.contains('hidden')) {
                    overlayBeforeAd = id;
                    el.classList.add('hidden');
                }
            });

            // Add class to body so CSS can force GameMonetize to top
            document.body.classList.add('ad-playing');

            // Show our ad overlay (but it will be hidden by CSS while ad plays)
            document.getElementById('adOverlay').classList.remove('hidden');
            document.getElementById('closeAdBtn').style.display = 'none';
            document.getElementById('adTitle').textContent = isRewarded ? 'EARNING EXTRA LIFE!' : 'LOADING...';
            document.getElementById('adStatus').textContent = 'Please wait...';

            // Start countdown from 5
            let countdown = 5;
            document.getElementById('adCountdown').textContent = countdown;

            // Clear any existing interval
            if (adCountdownInterval) clearInterval(adCountdownInterval);

            adCountdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    document.getElementById('adCountdown').textContent = countdown;
                } else {
                    document.getElementById('adCountdown').textContent = isRewarded ? '+1 LIFE!' : 'GO!';
                    document.getElementById('adStatus').textContent = 'Ready!';
                }
            }, 1000);

            // Try to show real ad
            let adShown = false;
            if (typeof GameMonetize !== 'undefined' && GameMonetize.showAd) {
                try {
                    GameMonetize.showAd();
                    adShown = true;
                    console.log('Showing ad via GameMonetize.showAd()');
                } catch(e) {
                    console.log('GameMonetize.showAd error:', e);
                }
            }
            if (!adShown && typeof sdk !== 'undefined') {
                try {
                    if (sdk.showBanner) { sdk.showBanner(); adShown = true; }
                    else if (sdk.showAd) { sdk.showAd(); adShown = true; }
                } catch(e) { console.log('SDK ad error:', e); }
            }

            // Complete after countdown (5 seconds) regardless of ad
            setTimeout(() => {
                clearInterval(adCountdownInterval);
                finishAd(true);
            }, 5000);

            // Show skip button after 3 seconds
            setTimeout(() => {
                const skipBtn = document.getElementById('closeAdBtn');
                if (skipBtn && !document.getElementById('adOverlay').classList.contains('hidden')) {
                    skipBtn.style.display = 'block';
                }
            }, 3000);
        }

        function finishAd(success) {
            if (adCountdownInterval) {
                clearInterval(adCountdownInterval);
                adCountdownInterval = null;
            }

            // Remove ad-playing class
            document.body.classList.remove('ad-playing');

            document.getElementById('adOverlay').classList.add('hidden');
            document.getElementById('closeAdBtn').style.display = 'none';
            gamePaused = false; // UNPAUSE THE GAME
            adsWatched++;

            // Restore the overlay that was showing before ad (if any)
            if (overlayBeforeAd) {
                document.getElementById(overlayBeforeAd).classList.remove('hidden');
                overlayBeforeAd = null;
            }

            if (adCallback) {
                adCallback(success);
                adCallback = null;
            }
        }

        // Close ad button handler
        document.getElementById('closeAdBtn')?.addEventListener('click', () => {
            finishAd(true);
        });

        function showRewardedAd(onReward) {
            showAd((success) => {
                if (success && onReward) onReward();
            }, true); // true = isRewarded
        }

        // Share functionality
        const GAME_URL = 'https://mosalahgame.com';

        function shareScore(platform) {
            const text = `I scored ${totalScore} points in Mo Salah Goal Machine! Can you beat me? üèÜ‚öΩ`;
            const url = GAME_URL;

            switch(platform) {
                case 'twitter':
                    window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`, '_blank');
                    break;
                case 'whatsapp':
                    window.open(`https://wa.me/?text=${encodeURIComponent(text + ' ' + url)}`, '_blank');
                    break;
                case 'facebook':
                    window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}&quote=${encodeURIComponent(text)}`, '_blank');
                    break;
                case 'copy':
                    navigator.clipboard.writeText(text + ' ' + url).then(() => {
                        alert('Link copied! Share it with friends!');
                    });
                    break;
            }
        }

        // Tips system
        const tips = [
            "TIP: Hold SHOOT longer for more power, but careful - too much goes over!",
            "TIP: Move unpredictably to dodge defenders!",
            "TIP: Shoot when defenders are far away!",
            "TIP: In free kicks, aim high for top corner screamers!",
            "TIP: Medium power (yellow bar) is often best!",
            "TIP: Watch the keeper's position before shooting!",
            "TIP: You can earn extra lives by watching ads!",
            "TIP: Share your score to challenge friends!"
        ];
        let currentTip = 0;
        let tipTimer = 0;

        function getNextTip() {
            const tip = tips[currentTip];
            currentTip = (currentTip + 1) % tips.length;
            return tip;
        }

        // Intro scene state
        let introActive = true;
        let introFrame = 0;
        let introBallX = 100;
        let introBallY = 250;
        let introPhase = 'run'; // run, kick, goal, celebrate

        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ') {
                handleShootPress();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'r' && gameState === 'playing') {
                resetPositions();
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            if (e.key === ' ') handleShootRelease();
        });

        // Mobile controls
        const joystick = document.getElementById('joystick');
        const knob = document.getElementById('knob');
        const shootBtn = document.getElementById('shootBtn');
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let touchMove = { x: 0, y: 0 };

        joystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
            const rect = joystick.getBoundingClientRect();
            joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        });

        document.addEventListener('touchmove', (e) => {
            if (!joystickActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            const maxDist = 30;
            let dx = touch.clientX - joystickCenter.x;
            let dy = touch.clientY - joystickCenter.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
            knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            touchMove = { x: dx / maxDist, y: dy / maxDist };
        }, { passive: false });

        document.addEventListener('touchend', () => {
            if (joystickActive) {
                joystickActive = false;
                knob.style.transform = 'translate(-50%, -50%)';
                touchMove = { x: 0, y: 0 };
            }
        });

        shootBtn.addEventListener('touchstart', (e) => { e.preventDefault(); handleShootPress(); });
        shootBtn.addEventListener('touchend', (e) => { e.preventDefault(); handleShootRelease(); });

        function handleShootPress() {
            if (gameState === 'playing' && salah.hasBall && !shotCharging) {
                startCharging();
            } else if (gameState === 'freeKick' && freeKickPhase === 'aim' && !shotCharging) {
                startCharging();
            }
        }

        function handleShootRelease() {
            if (shotCharging) {
                if (gameState === 'playing' && salah.hasBall) {
                    shootBall(shotPower);
                } else if (gameState === 'freeKick' && freeKickPhase === 'aim') {
                    // FPV: Shoot directly with current power and target
                    shootFPVFreeKick();
                }
                shotCharging = false;
                shotPower = 0;
            }
        }

        function startCharging() {
            shotCharging = true;
            chargeStartTime = Date.now();
            shotPower = 0;
        }

        function shootBall(power) {
            gameState = 'shooting';
            salah.hasBall = false;
            salah.kickFrame = 10;

            const powerPercent = power / maxShotPower;
            const basePower = 10 + powerPercent * 8;
            const aimVariance = (Math.random() - 0.5) * 60;

            let goingOver = false;
            if (powerPercent > 0.75 && Math.random() < (powerPercent - 0.5) * 0.8) {
                goingOver = true;
            }

            ball.targetY = goingOver ? goal.y - 50 - Math.random() * 100 : goal.y + goal.height / 2 + aimVariance;
            ball.active = true;
            ball.velocityX = basePower;
            ball.velocityY = (ball.targetY - ball.y) / ((goal.x - ball.x) / basePower);
            ball.curve = 0;

            const level = levels[currentLevel];
            const reactionDelay = 100 + Math.random() * 150 + (powerPercent * 50);
            setTimeout(() => {
                if (gameState === 'shooting') {
                    const predictedY = ball.y + ball.velocityY * ((alisson.x - ball.x) / ball.velocityX);
                    alisson.targetY = predictedY;
                    alisson.diving = true;
                    alisson.diveDirection = predictedY > alisson.y ? 1 : -1;
                }
            }, reactionDelay);
        }

        function shootFreeKick() {
            gameState = 'shooting';
            salah.kickFrame = 10;

            const power = shotPower || 60;
            const powerPercent = power / maxShotPower;
            const basePower = 8 + powerPercent * 6;

            // Bend affects curve - more bend = more curve but harder to control
            const bendPercent = (bendAmount - 50) / 50; // -1 to 1
            ball.curve = bendPercent * 0.3;

            // Target based on bend
            const targetY = goal.y + goal.height / 2 + bendPercent * 80;

            ball.active = true;
            ball.velocityX = basePower;
            ball.velocityY = (targetY - ball.y) / ((goal.x - ball.x) / basePower) - ball.curve * 5;

            // High bend = risk of missing
            if (Math.abs(bendPercent) > 0.7 && Math.random() < Math.abs(bendPercent) * 0.3) {
                ball.velocityY += (Math.random() - 0.5) * 4;
            }

            const level = levels[currentLevel];
            setTimeout(() => {
                if (gameState === 'shooting') {
                    const predictedY = ball.y + ball.velocityY * ((alisson.x - ball.x) / ball.velocityX);
                    alisson.targetY = predictedY + ball.curve * 50; // Keeper misjudges curve
                    alisson.diving = true;
                    alisson.diveDirection = predictedY > alisson.y ? 1 : -1;
                }
            }, 150);
        }

        function resetPositions() {
            const level = levels[currentLevel];

            if (level.freeKick) {
                salah.x = 400;
                salah.y = 350;
                ball.x = 420;
                ball.y = 365;
                gameState = 'freeKick';
                freeKickPhase = 'aim';
                setupWall(level.wallSize || 4);
                // Reset FPV state
                fkTarget = { x: 400, y: 200 };
                fkBallPos = { x: 400, y: 480, z: 0 };
                fkBallVel = { x: 0, y: 0, z: 0 };
                fkKeeperPos = { x: 400, y: 180 };
                fkKeeperDiving = false;
                fkKeeperDiveDir = 0;
                fkPower = 0;
                fkCurve = 0;
                document.getElementById('message').textContent = 'AIM with joystick, HOLD SHOOT for power!';
            } else {
                salah.x = 200;
                salah.y = 250;
                ball.x = 220;
                ball.y = 270;
                gameState = 'playing';
                document.getElementById('message').textContent = 'Hold SHOOT to power up!';
            }

            salah.hasBall = true;
            salah.kickFrame = 0;
            salah.celebrating = false;
            salah.celebrateFrame = 0;
            ball.active = false;
            ball.velocityX = 0;
            ball.velocityY = 0;
            ball.curve = 0;
            alisson.x = 700;
            alisson.y = 250;
            alisson.diving = false;
            alisson.diveFrame = 0;
            shotCharging = false;
            shotPower = 0;

            // Reset defenders
            const defSpeed = level.defenderSpeed || 2.0;
            defenders.konate.x = 500; defenders.konate.y = 250; defenders.konate.speed = defSpeed;
            defenders.vandijk.x = 450; defenders.vandijk.y = 180; defenders.vandijk.speed = defSpeed * 0.9;
            defenders.robertson.x = 480; defenders.robertson.y = 320; defenders.robertson.speed = defSpeed * 1.1;
            defenders.bradley.x = 420; defenders.bradley.y = 250; defenders.bradley.speed = defSpeed * 1.05;
        }

        function setupWall(size) {
            wallPlayers = [];
            const startY = goal.y + goal.height / 2 - (size * 25) / 2;
            for (let i = 0; i < size; i++) {
                wallPlayers.push({ x: 550, y: startY + i * 25, width: 20, height: 45 });
            }
        }

        function startLevel(levelIndex) {
            currentLevel = levelIndex;
            levelGoals = 0;
            const level = levels[currentLevel];
            document.getElementById('level').textContent = level.suddenDeath ? 'SD' : (currentLevel + 1);
            document.getElementById('target').textContent = level.suddenDeath ? '‚àû' : level.target;
            document.getElementById('goals').textContent = '0';
            resetPositions();
            document.getElementById('levelOverlay').classList.add('hidden');

            // Show sudden death announcement
            if (level.suddenDeath) {
                document.getElementById('message').textContent = 'SUDDEN DEATH! Score until you drop!';
            }
        }

        function completeLevel() {
            const level = levels[currentLevel];
            const bonus = level.freeKick ? 50 : level.target * 10;
            totalScore += bonus;
            document.getElementById('totalScore').textContent = totalScore;

            if (currentLevel < levels.length - 1) {
                const nextLevel = levels[currentLevel + 1];
                if (nextLevel.suddenDeath) {
                    document.getElementById('levelTitle').textContent = 'FINAL LEVEL!';
                    document.getElementById('levelScore').textContent = `+${bonus} points! Total: ${totalScore}`;
                    document.getElementById('levelDesc').textContent = 'SUDDEN DEATH: Endless mode! Score as many as you can before losing all lives. Your final score = LIMITLESS!';
                } else {
                    document.getElementById('levelTitle').textContent = 'LEVEL COMPLETE!';
                    document.getElementById('levelScore').textContent = `+${bonus} points!`;
                    document.getElementById('levelDesc').textContent = nextLevel.desc;
                }
                document.getElementById('levelOverlay').classList.remove('hidden');
                gameState = 'levelComplete';
            } else {
                // This shouldn't happen in Sudden Death but just in case
                endGame(true);
            }
        }

        async function endGame(completed) {
            gameState = 'gameOver';
            document.getElementById('finalScore').textContent = totalScore;

            const level = levels[currentLevel];
            let msg;
            if (level && level.suddenDeath) {
                msg = `SUDDEN DEATH: ${levelGoals} goals scored!`;
            } else if (completed) {
                msg = 'INCREDIBLE! You completed all levels!';
            } else {
                msg = `You reached Level ${currentLevel + 1}`;
            }
            document.getElementById('gameOverMsg').textContent = msg;
            document.getElementById('gameOverOverlay').classList.remove('hidden');

            // Save score and refresh leaderboard
            await saveScore(playerName, totalScore);
            await displayLeaderboard('gameOverLeaderboard');
        }

        function handleGoal() {
            levelGoals++;
            const level = levels[currentLevel];

            // Sudden death gives bonus points per goal
            const goalPoints = level.suddenDeath ? 15 : 10;
            totalScore += goalPoints;

            document.getElementById('goals').textContent = levelGoals;
            document.getElementById('totalScore').textContent = totalScore;

            const isFreeKick = level.freeKick;
            const isSuddenDeath = level.suddenDeath;

            if (isSuddenDeath) {
                document.getElementById('message').textContent = `GOAL #${levelGoals}! +${goalPoints} pts! Keep going!`;
            } else {
                document.getElementById('message').textContent = isFreeKick
                    ? randomMessage(freeKickMessages)
                    : randomMessage(goalMessages);
            }

            gameState = 'celebrating';
            salah.celebrating = true;
            salah.celebrateFrame = 0;

            setTimeout(() => {
                // In Sudden Death, never complete - just keep playing
                if (isSuddenDeath) {
                    resetPositions();
                } else if (levelGoals >= level.target) {
                    completeLevel();
                } else {
                    resetPositions();
                }
            }, 2000);
        }

        function handleMiss(isSave) {
            lives--;
            document.getElementById('message').textContent = isSave
                ? randomMessage(saveMessages)
                : randomMessage(missMessages);
            gameState = 'saved';

            if (lives <= 0) {
                setTimeout(() => endGame(false), 1500);
            } else {
                setTimeout(resetPositions, 1500);
            }
        }

        function handleTackle(defenderName) {
            lives--;
            const name = defenderName.charAt(0).toUpperCase() + defenderName.slice(1).replace('-', ' ');
            document.getElementById('message').textContent = `${name}: ${randomMessage(tackleMessages)}`;
            gameState = 'tackled';

            if (lives <= 0) {
                setTimeout(() => endGame(false), 1500);
            } else {
                setTimeout(resetPositions, 1500);
            }
        }

        // Drawing functions
        function drawField() {
            ctx.fillStyle = '#2d5a27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#347a2c';
            for (let i = 0; i < canvas.width; i += 60) ctx.fillRect(i, 0, 30, canvas.height);

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.strokeRect(600, 100, 200, 300);
            ctx.strokeRect(700, 175, 100, 150);

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(650, 250, 4, 0, Math.PI * 2);
            ctx.fill();

            // Free kick spot
            if (levels[currentLevel]?.freeKick) {
                ctx.beginPath();
                ctx.arc(420, 365, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Goal
            ctx.fillStyle = '#fff';
            ctx.fillRect(goal.x, goal.y, goal.postWidth, goal.height);
            ctx.fillRect(goal.x, goal.y, goal.width, goal.postWidth);
            ctx.fillRect(goal.x, goal.y + goal.height - goal.postWidth, goal.width, goal.postWidth);

            // Net
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            for (let i = goal.y; i < goal.y + goal.height; i += 15) {
                ctx.beginPath(); ctx.moveTo(goal.x + goal.postWidth, i); ctx.lineTo(goal.x + goal.width, i); ctx.stroke();
            }
            for (let i = goal.x + goal.postWidth; i < goal.x + goal.width; i += 15) {
                ctx.beginPath(); ctx.moveTo(i, goal.y); ctx.lineTo(i, goal.y + goal.height); ctx.stroke();
            }

            // Lives indicator
            ctx.fillStyle = '#c8102e';
            for (let i = 0; i < lives; i++) {
                ctx.beginPath();
                ctx.arc(30 + i * 25, 25, 8, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawSalah(x, y) {
            const skinColor = '#c68642';
            const hairColor = '#1a1a1a';
            const shirtColor = '#c8102e';

            // Curly hair
            ctx.fillStyle = hairColor;
            ctx.fillRect(x + 4, y - 4, 24, 12);
            ctx.fillRect(x, y, 8, 8);
            ctx.fillRect(x + 24, y, 8, 8);
            ctx.fillRect(x + 2, y + 6, 6, 8);
            ctx.fillRect(x + 24, y + 6, 6, 8);

            // Head
            ctx.fillStyle = skinColor;
            ctx.fillRect(x + 6, y + 4, 20, 18);

            // Eyes
            ctx.fillStyle = '#000';
            ctx.fillRect(x + 10, y + 10, 4, 4);
            ctx.fillRect(x + 18, y + 10, 4, 4);

            // Beard
            ctx.fillStyle = hairColor;
            ctx.fillRect(x + 6, y + 16, 20, 6);
            ctx.fillRect(x + 10, y + 14, 12, 4);

            // Body
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + 4, y + 22, 24, 18);

            // Number 11
            ctx.fillStyle = '#fff';
            ctx.fillRect(x + 10, y + 26, 3, 10);
            ctx.fillRect(x + 18, y + 26, 3, 10);

            // Arms
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x - 2, y + 22, 8, 14);
            ctx.fillRect(x + 26, y + 22, 8, 14);

            // Hands
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 2, y + 34, 6, 6);
            ctx.fillRect(x + 28, y + 34, 6, 6);

            // Shorts & legs
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + 6, y + 40, 20, 10);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x + 8, y + 50, 6, 10);
            ctx.fillRect(x + 18, y + 50, 6, 10);

            // Boots
            ctx.fillStyle = '#f97316';
            ctx.fillRect(x + 6, y + 58, 10, 6);
            ctx.fillRect(x + 16, y + 58, 10, 6);

            // Kick animation
            if (salah.kickFrame > 0) {
                ctx.fillStyle = skinColor;
                ctx.fillRect(x + 24, y + 48, 12, 6);
                ctx.fillStyle = '#f97316';
                ctx.fillRect(x + 32, y + 48, 10, 6);
            }

            // Celebration
            if (salah.celebrating) {
                const jump = Math.sin(salah.celebrateFrame * 0.3) * 10;
                const wave = Math.sin(salah.celebrateFrame * 0.5) * 8;
                ctx.fillStyle = shirtColor;
                ctx.fillRect(x - 6, y + 10 - jump + wave, 10, 16);
                ctx.fillRect(x + 28, y + 10 - jump - wave, 10, 16);
                ctx.fillStyle = skinColor;
                ctx.fillRect(x - 6, y + 4 - jump + wave, 8, 8);
                ctx.fillRect(x + 30, y + 4 - jump - wave, 8, 8);
            }
        }

        function drawAlisson(x, y, diving, diveDir) {
            const skinColor = '#d4a574';
            const hairColor = '#4a3728';
            const shirtColor = '#32CD32';
            const shortsColor = '#228B22';
            const glovesColor = '#FFD700';

            if (diving) {
                const offset = Math.min(alisson.diveFrame * 3, 40) * diveDir;
                y += offset;
                ctx.fillStyle = shirtColor;
                ctx.fillRect(x - 8, y + 16, 40, 16);
                ctx.fillRect(x - 16, y + 8, 16, 12);
                ctx.fillRect(x + 32, y + 8, 16, 12);
                ctx.fillStyle = glovesColor;
                ctx.fillRect(x - 24, y + 8, 12, 16);
                ctx.fillRect(x + 44, y + 8, 12, 16);
                ctx.fillStyle = skinColor;
                ctx.fillRect(x + 8, y, 20, 20);
                ctx.fillStyle = hairColor;
                ctx.fillRect(x + 8, y, 20, 8);
                ctx.fillStyle = shortsColor;
                ctx.fillRect(x, y + 32, 32, 8);
            } else {
                ctx.fillStyle = skinColor;
                ctx.fillRect(x + 8, y, 20, 20);
                ctx.fillStyle = hairColor;
                ctx.fillRect(x + 8, y, 20, 8);
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 12, y + 10, 4, 4);
                ctx.fillRect(x + 20, y + 10, 4, 4);
                ctx.fillStyle = shirtColor;
                ctx.fillRect(x + 4, y + 20, 28, 20);
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 16, y + 24, 4, 12);
                ctx.fillStyle = shirtColor;
                ctx.fillRect(x - 4, y + 20, 8, 16);
                ctx.fillRect(x + 32, y + 20, 8, 16);
                ctx.fillStyle = glovesColor;
                ctx.fillRect(x - 4, y + 32, 10, 10);
                ctx.fillRect(x + 30, y + 32, 10, 10);
                ctx.fillStyle = shortsColor;
                ctx.fillRect(x + 6, y + 40, 24, 10);
                ctx.fillStyle = skinColor;
                ctx.fillRect(x + 8, y + 50, 8, 12);
                ctx.fillRect(x + 20, y + 50, 8, 12);
                ctx.fillStyle = '#111';
                ctx.fillRect(x + 6, y + 60, 12, 6);
                ctx.fillRect(x + 18, y + 60, 12, 6);
            }
        }

        function drawDefender(x, y, number, skinColor) {
            const hairColor = '#1a1a1a';
            const shirtColor = '#c8102e';

            ctx.fillStyle = hairColor;
            ctx.fillRect(x + 6, y - 2, 20, 6);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x + 6, y + 2, 20, 20);
            ctx.fillStyle = '#fff';
            ctx.fillRect(x + 10, y + 10, 5, 4);
            ctx.fillRect(x + 17, y + 10, 5, 4);
            ctx.fillStyle = '#000';
            ctx.fillRect(x + 12, y + 11, 2, 2);
            ctx.fillRect(x + 19, y + 11, 2, 2);
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + 2, y + 22, 28, 22);

            // Number
            ctx.fillStyle = '#fff';
            ctx.font = '10px monospace';
            ctx.fillText(number.toString(), x + 10, y + 38);

            ctx.fillStyle = shirtColor;
            ctx.fillRect(x - 4, y + 22, 8, 16);
            ctx.fillRect(x + 28, y + 22, 8, 16);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 4, y + 36, 6, 6);
            ctx.fillRect(x + 30, y + 36, 6, 6);
            ctx.fillStyle = shirtColor;
            ctx.fillRect(x + 4, y + 44, 24, 12);
            ctx.fillStyle = skinColor;
            ctx.fillRect(x + 6, y + 56, 8, 14);
            ctx.fillRect(x + 18, y + 56, 8, 14);
            ctx.fillStyle = '#111';
            ctx.fillRect(x + 4, y + 68, 12, 6);
            ctx.fillRect(x + 16, y + 68, 12, 6);
        }

        function drawWall() {
            wallPlayers.forEach(p => {
                ctx.fillStyle = '#c8102e';
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(p.x + 4, p.y, 12, 12);
            });
        }

        function drawBall() {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(ball.x + 2, ball.y + ball.radius + 4, ball.radius, ball.radius / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(ball.x - 2, ball.y - 2, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPowerMeter() {
            if (shotCharging) {
                const meterWidth = 100;
                const meterHeight = 12;
                const x = salah.x - 20;
                const y = salah.y - 30;
                const fillWidth = (shotPower / maxShotPower) * meterWidth;

                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(x - 2, y - 2, meterWidth + 4, meterHeight + 4);

                const powerPercent = shotPower / maxShotPower;
                ctx.fillStyle = powerPercent < 0.5 ? '#4ade80' : powerPercent < 0.75 ? '#fbbf24' : '#ef4444';
                ctx.fillRect(x, y, fillWidth, meterHeight);

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, meterWidth, meterHeight);

                ctx.fillStyle = '#fff';
                ctx.font = '8px monospace';
                ctx.fillText('POWER', x + 30, y - 5);
            }
        }

        function drawBendMeter() {
            if (gameState === 'bendSelect') {
                const meterWidth = 200;
                const meterHeight = 20;
                const x = canvas.width / 2 - meterWidth / 2;
                const y = 50;

                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(x - 5, y - 25, meterWidth + 10, meterHeight + 35);

                // Gradient for bend
                const gradient = ctx.createLinearGradient(x, 0, x + meterWidth, 0);
                gradient.addColorStop(0, '#3b82f6');
                gradient.addColorStop(0.5, '#4ade80');
                gradient.addColorStop(1, '#f59e0b');
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, meterWidth, meterHeight);

                // Indicator
                const indicatorX = x + (bendAmount / 100) * meterWidth;
                ctx.fillStyle = '#fff';
                ctx.fillRect(indicatorX - 3, y - 5, 6, meterHeight + 10);

                ctx.fillStyle = '#fff';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('LEFT          STRAIGHT          RIGHT', x + meterWidth / 2, y - 10);
                ctx.fillText('TAP SHOOT TO CONFIRM', x + meterWidth / 2, y + meterHeight + 15);
                ctx.textAlign = 'left';
            }
        }

        // ========== FPV FREE KICK SYSTEM ==========
        function drawFPVFreeKick() {
            // Sky gradient
            const skyGrad = ctx.createLinearGradient(0, 0, 0, 250);
            skyGrad.addColorStop(0, '#1a1a3e');
            skyGrad.addColorStop(1, '#2d4a6e');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, canvas.width, 250);

            // Stadium lights glow
            ctx.fillStyle = 'rgba(255,255,200,0.1)';
            ctx.beginPath();
            ctx.arc(200, 50, 80, 0, Math.PI * 2);
            ctx.arc(600, 50, 80, 0, Math.PI * 2);
            ctx.fill();

            // Pitch - perspective
            const pitchGrad = ctx.createLinearGradient(0, 250, 0, 500);
            pitchGrad.addColorStop(0, '#2d5a27');
            pitchGrad.addColorStop(1, '#1d4a17');
            ctx.fillStyle = pitchGrad;
            ctx.fillRect(0, 250, canvas.width, 250);

            // Pitch stripes (perspective)
            ctx.fillStyle = '#347a2c';
            for (let i = 0; i < 8; i++) {
                const y1 = 250 + i * 30;
                const y2 = 250 + (i + 1) * 30;
                if (i % 2 === 0) {
                    ctx.beginPath();
                    ctx.moveTo(0, y1);
                    ctx.lineTo(canvas.width, y1);
                    ctx.lineTo(canvas.width, y2);
                    ctx.lineTo(0, y2);
                    ctx.fill();
                }
            }

            // Goal frame (perspective - larger at bottom)
            const goalTop = 120;
            const goalBottom = 280;
            const goalLeft = 200;
            const goalRight = 600;
            const goalTopLeft = 280;
            const goalTopRight = 520;

            // Goal net
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 10; i++) {
                const x1 = goalTopLeft + (goalLeft - goalTopLeft) * (i / 10);
                const x2 = goalTopRight + (goalRight - goalTopRight) * (i / 10);
                const y = goalTop + (goalBottom - goalTop) * (i / 10);
                ctx.beginPath();
                ctx.moveTo(x1, y);
                ctx.lineTo(x2, y);
                ctx.stroke();
            }
            for (let i = 0; i <= 8; i++) {
                const topX = goalTopLeft + (goalTopRight - goalTopLeft) * (i / 8);
                const botX = goalLeft + (goalRight - goalLeft) * (i / 8);
                ctx.beginPath();
                ctx.moveTo(topX, goalTop);
                ctx.lineTo(botX, goalBottom);
                ctx.stroke();
            }

            // Goal posts
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(goalTopLeft, goalTop);
            ctx.lineTo(goalLeft, goalBottom);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(goalTopRight, goalTop);
            ctx.lineTo(goalRight, goalBottom);
            ctx.stroke();
            // Crossbar
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(goalTopLeft, goalTop);
            ctx.lineTo(goalTopRight, goalTop);
            ctx.stroke();

            // Keeper (Alisson) - FPV view
            const keeperX = fkKeeperPos.x;
            const keeperY = fkKeeperPos.y;
            if (fkKeeperDiving) {
                // Diving keeper
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(keeperX - 25 + fkKeeperDiveDir * 30, keeperY, 50, 20);
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(keeperX - 10 + fkKeeperDiveDir * 40, keeperY - 5, 15, 15);
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(keeperX - 30 + fkKeeperDiveDir * 50, keeperY, 12, 12);
            } else {
                // Standing keeper
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(keeperX - 15, keeperY, 30, 50);
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(keeperX - 10, keeperY - 15, 20, 20);
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(keeperX - 25, keeperY + 10, 12, 15);
                ctx.fillRect(keeperX + 13, keeperY + 10, 12, 15);
            }

            // Wall of defenders (facing camera!)
            const wallY = 320;
            const level = levels[currentLevel];
            const wallSize = level.wallSize || 3;
            const wallSpacing = 45;
            const wallStartX = 400 - ((wallSize - 1) * wallSpacing) / 2;

            for (let i = 0; i < wallSize; i++) {
                const wx = wallStartX + i * wallSpacing;
                // Body (facing us)
                ctx.fillStyle = '#c8102e';
                ctx.fillRect(wx - 18, wallY, 36, 45);
                // Head
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(wx - 12, wallY - 18, 24, 22);
                // Hair
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(wx - 12, wallY - 18, 24, 8);
                // Eyes (looking at ball nervously)
                ctx.fillStyle = '#fff';
                ctx.fillRect(wx - 8, wallY - 8, 7, 5);
                ctx.fillRect(wx + 1, wallY - 8, 7, 5);
                ctx.fillStyle = '#000';
                ctx.fillRect(wx - 5, wallY - 7, 3, 3);
                ctx.fillRect(wx + 4, wallY - 7, 3, 3);
                // Hands covering... area
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(wx - 10, wallY + 30, 20, 12);
                // Legs
                ctx.fillStyle = '#c8102e';
                ctx.fillRect(wx - 14, wallY + 45, 12, 20);
                ctx.fillRect(wx + 2, wallY + 45, 12, 20);
            }

            // Player lying BEHIND the wall
            ctx.fillStyle = '#c8102e';
            ctx.fillRect(340, wallY + 65, 50, 12);
            ctx.fillStyle = '#d4a574';
            ctx.fillRect(330, wallY + 63, 12, 12);

            // Target reticle (where you're aiming)
            if (freeKickPhase === 'aim') {
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(fkTarget.x, fkTarget.y, 20, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(fkTarget.x - 30, fkTarget.y);
                ctx.lineTo(fkTarget.x - 10, fkTarget.y);
                ctx.moveTo(fkTarget.x + 10, fkTarget.y);
                ctx.lineTo(fkTarget.x + 30, fkTarget.y);
                ctx.moveTo(fkTarget.x, fkTarget.y - 30);
                ctx.lineTo(fkTarget.x, fkTarget.y - 10);
                ctx.moveTo(fkTarget.x, fkTarget.y + 10);
                ctx.lineTo(fkTarget.x, fkTarget.y + 30);
                ctx.stroke();

                // Hint text based on target position
                let hint = '';
                if (fkTarget.y < 180) hint = 'TOP CORNER - SCREAMER!';
                else if (fkTarget.y > 240) hint = 'LOW & HARD';
                else hint = 'MID HEIGHT';

                if (fkTarget.x < 350) hint += ' (CURL LEFT)';
                else if (fkTarget.x > 450) hint += ' (CURL RIGHT)';

                ctx.fillStyle = '#ffd700';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(hint, 400, 80);
                ctx.fillText('MOVE TO AIM - HOLD SHOOT FOR POWER', 400, 470);
                ctx.textAlign = 'left';
            }

            // Power meter (when charging)
            if (shotCharging && freeKickPhase === 'aim') {
                const pw = 200;
                const ph = 20;
                const px = 300;
                const py = 430;
                const fill = (shotPower / maxShotPower) * pw;

                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(px - 5, py - 5, pw + 10, ph + 10);

                const powerPct = shotPower / maxShotPower;
                ctx.fillStyle = powerPct < 0.4 ? '#4ade80' : powerPct < 0.7 ? '#fbbf24' : '#ef4444';
                ctx.fillRect(px, py, fill, ph);

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(px, py, pw, ph);

                ctx.fillStyle = '#fff';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('POWER', 400, py - 10);
                if (powerPct < 0.4) ctx.fillText('LOW - AROUND WALL', 400, py + 40);
                else if (powerPct < 0.7) ctx.fillText('MEDIUM - DIPPING', 400, py + 40);
                else ctx.fillText('HIGH - OVER WALL', 400, py + 40);
                ctx.textAlign = 'left';
            }

            // Ball in flight
            if (freeKickPhase === 'flying') {
                const ballSize = 15 - fkBallPos.z * 0.03;
                const ballScreenX = fkBallPos.x;
                const ballScreenY = fkBallPos.y - fkBallPos.z * 0.5;

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(ballScreenX, ballScreenY, Math.max(ballSize, 3), 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(ballScreenX - 2, ballScreenY - 2, ballSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Ball at feet (before shot)
            if (freeKickPhase === 'aim') {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(400, 480, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(396, 476, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function updateFPVFreeKick() {
            const level = levels[currentLevel];

            // Move target with joystick/keys
            if (freeKickPhase === 'aim') {
                const moveSpeed = 4;
                if (keys['arrowleft'] || keys['a']) fkTarget.x -= moveSpeed;
                if (keys['arrowright'] || keys['d']) fkTarget.x += moveSpeed;
                if (keys['arrowup'] || keys['w']) fkTarget.y -= moveSpeed;
                if (keys['arrowdown'] || keys['s']) fkTarget.y += moveSpeed;

                if (touchMove.x !== 0 || touchMove.y !== 0) {
                    fkTarget.x += touchMove.x * moveSpeed;
                    fkTarget.y += touchMove.y * moveSpeed;
                }

                // Clamp target to goal area
                fkTarget.x = Math.max(220, Math.min(580, fkTarget.x));
                fkTarget.y = Math.max(130, Math.min(270, fkTarget.y));
            }

            // Ball in flight physics
            if (freeKickPhase === 'flying') {
                fkBallPos.x += fkBallVel.x;
                fkBallPos.y += fkBallVel.y;
                fkBallPos.z += fkBallVel.z;

                // Apply curve
                fkBallVel.x += fkCurve * 0.1;

                // Gravity effect on arc
                if (fkBallVel.z > 0) {
                    fkBallVel.z -= 0.15;
                }

                // Keeper reaction
                if (!fkKeeperDiving && fkBallPos.z > 50) {
                    fkKeeperDiving = true;
                    // Keeper dives - sometimes wrong way!
                    const targetX = fkTarget.x + fkCurve * 50;
                    fkKeeperDiveDir = targetX < 400 ? -1 : 1;
                    // 30% chance keeper guesses wrong
                    if (Math.random() < 0.3) fkKeeperDiveDir *= -1;
                }

                if (fkKeeperDiving) {
                    fkKeeperPos.x += fkKeeperDiveDir * 8;
                }

                // Check if ball reached goal
                if (fkBallPos.z > 200) {
                    const finalX = fkBallPos.x;
                    const finalY = fkBallPos.y - fkBallPos.z * 0.3;

                    // Check if keeper saved it
                    const keeperDist = Math.abs(finalX - fkKeeperPos.x);
                    const heightFactor = fkTarget.y < 160 ? 1.5 : 1; // Top corners harder to save

                    // Check wall hit (low shots)
                    const hitWall = fkPower < 40 && Math.abs(finalX - 400) < 80 && finalY > 300;

                    if (hitWall) {
                        document.getElementById('message').textContent = 'BLOCKED BY THE WALL!';
                        handleMiss(false);
                    } else if (keeperDist < 60 / heightFactor && Math.random() > 0.3) {
                        document.getElementById('message').textContent = randomMessage(saveMessages);
                        handleMiss(true);
                    } else if (finalX < 220 || finalX > 580 || finalY < 120 || finalY > 280) {
                        document.getElementById('message').textContent = randomMessage(missMessages);
                        handleMiss(false);
                    } else {
                        // GOAL!
                        document.getElementById('message').textContent = randomMessage(freeKickMessages);
                        handleGoal();
                    }
                }
            }
        }

        function shootFPVFreeKick() {
            freeKickPhase = 'flying';
            fkPower = shotPower;

            // Calculate trajectory based on target and power
            const dx = fkTarget.x - 400;
            const dy = fkTarget.y - 480;

            // Curve based on horizontal target offset
            fkCurve = dx * 0.02;

            // Ball velocity
            fkBallVel.x = dx * 0.08;
            fkBallVel.y = dy * 0.06;
            fkBallVel.z = 5 + (fkPower / maxShotPower) * 8; // Height based on power

            // Reset ball position
            fkBallPos = { x: 400, y: 480, z: 0 };

            shotCharging = false;
            shotPower = 0;
        }

        function drawCelebration() {
            if (gameState === 'celebrating') {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                for (let i = 0; i < 20; i++) {
                    ctx.fillStyle = ['#c8102e', '#ffd700', '#fff'][Math.floor(Math.random() * 3)];
                    ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 8, 8);
                }
            }
        }

        function updateGame() {
            if (gameState === 'menu' || gameState === 'levelComplete' || gameState === 'gameOver' || gamePaused) return;

            // Update shot power
            if (shotCharging) {
                shotPower = Math.min(maxShotPower, (Date.now() - chargeStartTime) / 10);
            }

            const level = levels[currentLevel];

            // Move Salah (not in free kick)
            if (gameState === 'playing' && !level.freeKick) {
                if ((keys['arrowleft'] || keys['a']) && salah.x > 50) salah.x -= salah.speed;
                if ((keys['arrowright'] || keys['d']) && salah.x < 600) salah.x += salah.speed;
                if ((keys['arrowup'] || keys['w']) && salah.y > 50) salah.y -= salah.speed;
                if ((keys['arrowdown'] || keys['s']) && salah.y < 420) salah.y += salah.speed;

                if (touchMove.x !== 0 || touchMove.y !== 0) {
                    const newX = salah.x + touchMove.x * salah.speed;
                    const newY = salah.y + touchMove.y * salah.speed;
                    if (newX > 50 && newX < 600) salah.x = newX;
                    if (newY > 50 && newY < 420) salah.y = newY;
                }

                if (salah.hasBall) {
                    ball.x = salah.x + 20;
                    ball.y = salah.y + 45;
                }

                // Defenders chase
                level.defenders.forEach(defName => {
                    const def = defenders[defName];
                    if (!def) return;
                    const dx = salah.x - def.x;
                    const dy = salah.y - def.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 5) {
                        def.x += (dx / dist) * def.speed;
                        def.y += (dy / dist) * def.speed;
                    }
                    if (salah.hasBall && dist < def.tackleRange) {
                        handleTackle(defName);
                    }
                });
            }

            // Update ball
            if (ball.active) {
                ball.x += ball.velocityX;
                ball.y += ball.velocityY;
                ball.velocityY += ball.curve; // Apply curve

                // Check wall collision (free kick)
                if (level.freeKick) {
                    for (const p of wallPlayers) {
                        if (ball.x > p.x && ball.x < p.x + p.width + 10 &&
                            ball.y > p.y && ball.y < p.y + p.height) {
                            ball.velocityX *= -0.3;
                            ball.velocityY = (Math.random() - 0.5) * 8;
                            document.getElementById('message').textContent = 'Blocked by the wall!';
                            gameState = 'saved';
                            setTimeout(() => handleMiss(false), 1000);
                            break;
                        }
                    }
                }

                // Goal check
                if (ball.x >= goal.x && ball.y > goal.y + goal.postWidth && ball.y < goal.y + goal.height - goal.postWidth) {
                    if (gameState === 'shooting') handleGoal();
                }

                // Save check
                if (ball.x > alisson.x - 20 && ball.x < alisson.x + alisson.width + 20 &&
                    ball.y > alisson.y - 10 && ball.y < alisson.y + alisson.height + 20) {
                    if (gameState === 'shooting') {
                        ball.velocityX = -ball.velocityX * 0.5;
                        ball.velocityY = (Math.random() - 0.5) * 5;
                        handleMiss(true);
                    }
                }

                // Out of bounds
                if (ball.x > canvas.width || ball.y < 0 || ball.y > canvas.height) {
                    if (gameState === 'shooting') handleMiss(false);
                }

                ball.velocityX *= 0.995;
                ball.velocityY *= 0.995;
            }

            // Update Alisson
            if (alisson.diving) {
                alisson.diveFrame++;
                const targetY = Math.max(goal.y, Math.min(goal.y + goal.height - alisson.height, alisson.targetY));
                alisson.y += (targetY - alisson.y) * 0.15;
            } else if (gameState === 'playing') {
                const targetY = ball.y - alisson.height / 2;
                const clampedTarget = Math.max(goal.y, Math.min(goal.y + goal.height - alisson.height, targetY));
                alisson.y += (clampedTarget - alisson.y) * level.keeperSpeed;
            }

            if (salah.kickFrame > 0) salah.kickFrame--;
            if (salah.celebrating) salah.celebrateFrame++;
        }

        function gameLoop() {
            updateGame();

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const level = levels[currentLevel];

            // FPV mode for free kicks
            if (level?.freeKick && (gameState === 'freeKick' || freeKickPhase === 'flying')) {
                // Update FPV free kick logic
                updateFPVFreeKick();
                // Draw FPV view
                drawFPVFreeKick();
                // Draw celebration overlay if celebrating
                drawCelebration();
            } else {
                // Normal game view
                drawField();

                // Draw defenders
                if (level && !level.freeKick) {
                    level.defenders.forEach(defName => {
                        const def = defenders[defName];
                        if (def) drawDefender(def.x, def.y, def.number, def.skin);
                    });
                }

                drawSalah(salah.x, salah.y);
                drawAlisson(alisson.x, alisson.y, alisson.diving, alisson.diveDirection);
                drawBall();
                drawPowerMeter();
                drawCelebration();
                drawTip();
            }

            requestAnimationFrame(gameLoop);
        }

        // Draw tips at bottom of screen
        function drawTip() {
            if (gameState === 'playing' || gameState === 'freeKick') {
                tipTimer++;
                if (tipTimer > 600) { // Change tip every 10 seconds
                    tipTimer = 0;
                    currentTip = (currentTip + 1) % tips.length;
                }

                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, canvas.height - 25, canvas.width, 25);
                ctx.fillStyle = '#ffd700';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(tips[currentTip], canvas.width / 2, canvas.height - 8);
                ctx.textAlign = 'left';
            }
        }

        // Intro scene
        const introCanvas = document.getElementById('introCanvas');
        const introCtx = introCanvas ? introCanvas.getContext('2d') : null;

        let introKeeperY = 150; // Keeper position for diving
        let introKeeperDiving = false;

        function drawIntroScene() {
            if (!introCtx) return;
            introCtx.fillStyle = '#2d5a27';
            introCtx.fillRect(0, 0, 400, 300);

            // Grass stripes
            introCtx.fillStyle = '#347a2c';
            for (let i = 0; i < 400; i += 40) introCtx.fillRect(i, 0, 20, 300);

            // Goal posts
            introCtx.fillStyle = '#fff';
            introCtx.fillRect(350, 100, 6, 100); // Left post
            introCtx.fillRect(350, 100, 45, 6);   // Crossbar
            introCtx.fillRect(350, 194, 45, 6);   // Bottom bar

            // Net (behind goal)
            introCtx.strokeStyle = 'rgba(255,255,255,0.4)';
            introCtx.lineWidth = 1;
            for (let i = 105; i < 195; i += 10) {
                introCtx.beginPath();
                introCtx.moveTo(356, i);
                introCtx.lineTo(390, i);
                introCtx.stroke();
            }
            for (let i = 360; i < 395; i += 10) {
                introCtx.beginPath();
                introCtx.moveTo(i, 105);
                introCtx.lineTo(i, 195);
                introCtx.stroke();
            }

            // Draw pixel Salah based on phase
            const salahX = Math.min(introBallX - 20, 280);

            if (introPhase === 'run' || introPhase === 'kick') {
                // Running Salah
                const bounce = Math.sin(introFrame * 0.3) * 3;
                introCtx.fillStyle = '#1a1a1a';
                introCtx.fillRect(salahX + 4, 135 + bounce, 16, 8);
                introCtx.fillStyle = '#c68642';
                introCtx.fillRect(salahX + 6, 140 + bounce, 12, 12);
                introCtx.fillStyle = '#c8102e';
                introCtx.fillRect(salahX + 4, 152 + bounce, 16, 14);
                introCtx.fillStyle = '#c68642';
                introCtx.fillRect(salahX + 6, 166 + bounce, 5, 8);
                introCtx.fillRect(salahX + 13, 166 + bounce, 5, 8);
            }

            if (introPhase === 'goal' || introPhase === 'celebrate') {
                // Celebrating Salah - sliding on knees with arms up
                const pump = Math.sin(introFrame * 0.15) * 3;
                introCtx.fillStyle = '#1a1a1a';
                introCtx.fillRect(salahX + 4, 145, 16, 8); // Hair
                introCtx.fillStyle = '#c68642';
                introCtx.fillRect(salahX + 6, 150, 12, 12); // Face
                introCtx.fillStyle = '#c8102e';
                introCtx.fillRect(salahX + 4, 162, 16, 14); // Body
                // Arms raised in celebration
                introCtx.fillRect(salahX - 4, 150 - pump, 8, 14);
                introCtx.fillRect(salahX + 20, 150 + pump, 8, 14);
                // Kneeling legs
                introCtx.fillStyle = '#c68642';
                introCtx.fillRect(salahX + 4, 176, 16, 6);
            }

            // Keeper (Alisson) - diving/defeated
            if (introPhase === 'goal' || introPhase === 'celebrate') {
                // Alisson on knees, defeated
                introCtx.fillStyle = '#32CD32';
                introCtx.fillRect(338, 175, 20, 12); // Body lying
                introCtx.fillStyle = '#d4a574';
                introCtx.fillRect(335, 175, 8, 8); // Head down
                introCtx.fillStyle = '#FFD700'; // Gloves
                introCtx.fillRect(330, 180, 6, 6);
                introCtx.fillRect(356, 180, 6, 6);
            } else if (introPhase === 'kick') {
                // Alisson diving (wrong way!)
                introCtx.fillStyle = '#32CD32';
                introCtx.fillRect(335, introKeeperY + 20, 18, 10); // Diving body
                introCtx.fillStyle = '#d4a574';
                introCtx.fillRect(337, introKeeperY + 15, 8, 8); // Head
                introCtx.fillStyle = '#FFD700';
                introCtx.fillRect(332, introKeeperY + 10, 8, 10); // Gloves reaching
            } else {
                // Standing ready
                introCtx.fillStyle = '#32CD32';
                introCtx.fillRect(338, 135, 12, 30);
                introCtx.fillStyle = '#d4a574';
                introCtx.fillRect(340, 128, 8, 10);
                introCtx.fillStyle = '#FFD700';
                introCtx.fillRect(334, 138, 6, 8);
                introCtx.fillRect(348, 138, 6, 8);
            }

            // Ball - draw AFTER goal posts if it's in the net
            introCtx.fillStyle = '#fff';
            introCtx.beginPath();
            introCtx.arc(introBallX, introBallY, 6, 0, Math.PI * 2);
            introCtx.fill();
            introCtx.fillStyle = '#333';
            introCtx.beginPath();
            introCtx.arc(introBallX - 2, introBallY - 2, 2, 0, Math.PI * 2);
            introCtx.fill();

            // Title
            introCtx.fillStyle = '#c8102e';
            introCtx.font = 'bold 20px monospace';
            introCtx.textAlign = 'center';
            introCtx.fillText('MO SALAH', 200, 40);
            introCtx.fillStyle = '#ffd700';
            introCtx.font = '14px monospace';
            introCtx.fillText('GOAL MACHINE', 200, 60);
            introCtx.textAlign = 'left';

            if (introPhase === 'goal' || introPhase === 'celebrate') {
                // Net bulge effect - ball is IN the net
                introCtx.fillStyle = 'rgba(255,215,0,0.3)';
                introCtx.fillRect(0, 0, 400, 300);

                // GOAL text
                introCtx.fillStyle = '#ffd700';
                introCtx.font = 'bold 28px monospace';
                introCtx.textAlign = 'center';
                introCtx.strokeStyle = '#000';
                introCtx.lineWidth = 3;
                introCtx.strokeText('GOAL!', 200, 250);
                introCtx.fillText('GOAL!', 200, 250);

                // Confetti
                for (let i = 0; i < 15; i++) {
                    introCtx.fillStyle = ['#c8102e', '#ffd700', '#fff'][i % 3];
                    const cx = (introFrame * 2 + i * 30) % 400;
                    const cy = (introFrame + i * 20) % 300;
                    introCtx.fillRect(cx, cy, 4, 4);
                }
                introCtx.textAlign = 'left';
            }
        }

        function updateIntro() {
            introFrame++;

            if (introPhase === 'run') {
                introBallX += 1.5;
                if (introBallX > 300) {
                    introPhase = 'kick';
                    introKeeperDiving = true;
                }
            } else if (introPhase === 'kick') {
                introBallX += 5;
                // Ball curves into top corner
                introBallY = 150 + Math.sin((introBallX - 300) * 0.03) * -30;
                // Keeper dives wrong way
                if (introKeeperDiving) {
                    introKeeperY += 2; // Diving down while ball goes up!
                }
                // Ball reaches inside the goal (past the posts)
                if (introBallX > 375) {
                    introPhase = 'goal';
                    introBallX = 375; // Ball rests in back of net
                    introBallY = 130; // Top corner
                    setTimeout(() => { introPhase = 'celebrate'; }, 1500);
                }
            } else if (introPhase === 'celebrate') {
                if (introFrame > 500) {
                    skipIntro();
                }
            }
        }

        function introLoop() {
            if (!introActive) return;
            updateIntro();
            drawIntroScene();
            requestAnimationFrame(introLoop);
        }

        function skipIntro() {
            introActive = false;
            document.getElementById('introOverlay').classList.add('hidden');
            document.getElementById('startOverlay').classList.remove('hidden');
        }

        // Skip intro on button click or key press
        document.getElementById('skipIntroBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            skipIntro();
        });
        document.getElementById('skipIntroBtn').addEventListener('touchstart', (e) => {
            e.stopPropagation();
            skipIntro();
        });
        document.addEventListener('keydown', () => { if (introActive) skipIntro(); });

        // Menu handlers
        document.getElementById('startBtn').addEventListener('click', () => {
            playerName = document.getElementById('playerName').value.trim() || 'PLAYER';
            document.getElementById('startOverlay').classList.add('hidden');
            totalScore = 0;
            lives = 5;
            document.getElementById('totalScore').textContent = '0';
            startLevel(0);
        });

        document.getElementById('nextLevelBtn').addEventListener('click', () => {
            // Show ad between levels (every other level for better UX)
            if (currentLevel > 0 && currentLevel % 2 === 0) {
                showAd(() => {
                    startLevel(currentLevel + 1);
                });
            } else {
                startLevel(currentLevel + 1);
            }
        });

        document.getElementById('extraLifeBtn').addEventListener('click', () => {
            showRewardedAd(() => {
                lives++;
                document.getElementById('message').textContent = '+1 LIFE! You now have ' + lives + ' lives!';
            });
        });

        document.getElementById('continueAdBtn').addEventListener('click', () => {
            showRewardedAd(() => {
                // Give player another chance
                document.getElementById('gameOverOverlay').classList.add('hidden');
                lives = 1;
                resetPositions();
            });
        });

        document.getElementById('playAgainBtn').addEventListener('click', () => {
            // Show ad on replay
            showAd(() => {
                document.getElementById('gameOverOverlay').classList.add('hidden');
                totalScore = 0;
                lives = 5;
                document.getElementById('totalScore').textContent = '0';
                startLevel(0);
            });
        });

        document.getElementById('mainMenuBtn').addEventListener('click', () => {
            document.getElementById('gameOverOverlay').classList.add('hidden');
            document.getElementById('startOverlay').classList.remove('hidden');
            displayLeaderboard('leaderboard');
        });

        // Initialize
        document.getElementById('startOverlay').classList.add('hidden'); // Hide until intro done
        displayLeaderboard('leaderboard');
        introLoop(); // Start intro
        gameLoop();
    </script>
</body>
</html>
